> SOURCE: https://jhalon.github.io/chrome-browser-exploitation-1/

# Object Representation

Whenever an object is created, V8 creates a new JSObject and allocates memory for it on the heap. The value of the object is a pointer to the JSObject which contains the following within its structure:
- Map: A pointer to the HiddenClass object that details the “shape” or structure of the object.
- Properties: A pointer to an object containing named properties.
- Elements: A pointer to an object containing numbered properties.
- In-Object Properties: Pointers to named properties that were defined at object initialization

# Hidden Classes

Hidden classes work similarly to a fixed object layout where the values of properties (or pointers to those properties) can be stored in a specific memory structure and then accessed with a fixed-offset between each one. These offsets are generated by Torque and can be found in within the /torque-generated/src/objects/*.tq.inc directory in V8

As previously seen in the JSObject example above, the Map is another data structure within the object. That Map structure contains the following information:
- The dynamic type of the object, such as String, JSArray, HeapNumber, etc.
- Object Types in V8 are listed in /src/objects/objects.h
- Size of the object (in-object properties, etc.)
- Object properties and where they are stored
- Type of array elements
- Prototype or Shape of the object (if any)

More information on the structures can be found within V8’s source code and can be located within the /src/objects/map.h and /src/objects/descriptor-array.h source files.

Map layout: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/map.h;l=140
DescriptorArray layout: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/descriptor-array.h;l=37

Now do note, that a new hidden class is only created when a new property is added, adding an array-indexed property does not create new hidden classes.

# Why Hidden Classes?

Okay, I know that at this point some of you might ask, “why an offset to the property and not to it’s value”? 

What happens if a new object, such as obj2 is created which shares the same properties of obj1 such as x and y? Even though the values might be different the two objects actually share the same named properties in the same order, or as we would call it, the same “shape”. In that case it would be wasteful for us to store the same property name in two different locations. 

Since the property names are repeated for all objects within the same shape and because they’re in the same order, we can have multiple objects point to one single HiddenClass in memory with the offset to the properties instead of pointers to values. This also allows for easier garbage collection since Map’s are allocations of a HeapObject just like the JSObject is.

# Transition Tree

Now let’s focus on the back_pointer that’s highlighted in Green. If you look back into our C0 to C2 Map transition example, you’ll notice that we mentioned something called a “transition tree”. This transition tree is created in the background by V8 each time a new HiddenClass is created and allows V8 to link the new and old HiddenClasses together. This back_pointer is part of that transition tree as it points back to the parent map of where the transition occurred from. This allows V8 to walk the back pointer chain until it finds the map holding an objects properties, i.e. their shape.

Well, if we pay close attention to the information within that Map, we’ll notice that below the instance descriptor pointer there is a “transitions” section in Red. This transition section contains the information pointed to by the Raw Transition Pointer within the Map structure.

```c
// | TaggedPointer | [instance_descriptors]                          |
// +*****************************************************************+
// | TaggedPointer | [dependent_code]                                |
// +---------------+-------------------------------------------------+
// | TaggedPointer | [prototype_validity_cell]                       |
// +---------------+-------------------------------------------------+
// | TaggedPointer | If Map is a prototype map:                      |
// |               |   [prototype_info]                              |
// |               | Else:                                           |
// |               |   [raw_transitions]                             |
// +---------------+-------------------------------------------------+`
```

In V8, Map transitions use something called a TransitionsAccessor. This is a helper class that encapsulates access to the various ways a Map can store transitions to other maps in its respective field at Map::kTransitionsOrPrototypeInfo other known as the Raw Transition Pointer that we mentioned earlier. This pointer points to something known as a TransitionArray which again is a FixedArray that holds map transitions for property changes.

In the case that there was another transition, for example, z was added to x instead of y, then we would have two items within that transition array, each pointing to its respective map for that objects shape.

In the case the last property of an object is deleted, the Map will just adjust the back pointer to go back to its previous map, instead of creating a new one. But what happens if we delete the middle property of an object? Well in that case V8 will give up on maintaining the transition tree whenever we are adding too many attributes or deleting non-last elements, and it’ll switch to a slower mode known as dictionary mode.

# Properties Store

What is this In-Object Property that we are talking about?

Well, in V8 this mode is a very fast method of storing properties directly on the object since they are accessible without any indirection. Although they are very fast, they are also limited to the initial size of the object. If more properties get added than there is space in the object, then the new properties are stored within the properties store - which adds one level of indirection.

In general, there are two “modes” that JavaScript engines use to store properties, and those are called:
- Fast Properties: Typically used to define the properties stored in the linear properties store. These properties are simply accessed by index in the properties store by consulting the Descriptor Array array within the HiddenClass.
- Slow Properties: Also known as “dictionary mode”, this mode is utilized when there are too many properties being added or deleted - resulting in a lot of memory overhead. As a result, an object with slow properties will have a self-contained dictionary as a properties store. All the properties meta information is no longer stored in the Descriptor Array in the HiddenClass but directly in the properties dictionary. V8 will then use a hash table to access these properties.

# Elements Kinds

Even though all indexed properties are kept in the elements store, V8 makes a very precise distinction on what kind of elements each array contains. There is actually ~21 different types of elements that can be tracked within that store! This initially allows V8 to optimize any operations on the array specifically for that type of element.

So how does V8 use these element types for an array? Are they set for the array or for each element? The answer is that the element type is set for the array. The important thing we have to remember is that element kinds have a “transition” that only go in one direction. We can view this transition tree from a “top down” approach as such.

Since elements kind transitions go one way, once an array is marked with a lower elements kind, such as PACKED_DOUBLES_ELEMENTS it can no longer go back “up” to PACKED_SMI_ELEMENTS, even if we replace or remove that floating-point integer. In general, the more specific an elements kind is when you create an array, the more fine-grained optimizations are enabled. The further down the elements kind you go, the slower manipulations of that object might be.

# PACKED vs HOLEY

Next, we also need to understand the first major distinction that V8 has when it tracks element backing stores when an index is deleted, or empty. And those are:
- PACKED - Used to represent arrays that are dense, meaning that all available elements in the array have been populated.
- HOLEY - Used to represent arrays that have “holes” in them, such as when an indexed element is deleted, or not defined. This is also known as making an array “sparse”.

V8 also has a second major distinction made on elements that we need to understand. In the element backing stores, just like in the properties store, elements can also be either fast or in dictionary-mode (slow). Fast elements are simply an array where the property index maps to the offset of the item in the elements store. As for slow array’s, this happens when there are large sparse arrays where only a few entries are occupied. In this case, the array backing store uses a dictionary representation such as we’ve seen in the properties store to save memory at the cost of performance. That dictionary will store the key, value, and element attributes within the dictionary triplet values.

# Pointer Tagging

Pointer tagging’s technique is based on the observation that on x32 and x64 systems, allocated data must be at word-aligned (4 byte) boundaries. Because data is aligned this way, the least significant bits (LSB) will always be zero. Tagging will then use the two bottom bits or least significant bits to differentiate between a heap object pointer and an integer or SMI.

```c
            |----- 32 bits -----|----- 32 bits -------|
Pointer:    |________________address______________(w1)|
Smi:        |____int32_value____|000000000000000000(0)|
```


As you can see from the example, a 0 is used to represent a SMI, and a 1 is used to represent a pointer. Just one thing to note, is you are looking at SMI’s in memory, while they are stored inline, they are actually doubled to avoid a pointer tag. So, if you original value is 1, it will be 2 in the memory.

Within the pointer we also have a w in the second LSB which denotes a bit that is used to distinguish between a strong or weak pointer reference. If you’re not familiar with what a strong vs weak pointer is, I’ll explain. Simply a strong pointer is a pointer that indicates that the object pointed to must remain in memory (it represents an object), while a weak pointer is a pointer that simply points to data that might have been deleted. When the GC or garbage collector deletes an object, it has to delete the strong pointer as it’s the one that holds a reference count.

# Pointer Compression

Pointer Compression in Chrome and V8 makes use of an interesting property of objects on the heap, and that’s that heap objects are usually close to one another, so the most significant bits of the pointer will probably be the same. In that case, V8 only saves half of the pointer (the least significant bits) to memory and puts the most significant bits (upper 32 bits) of V8’s heap (known as the isolate root) into a root register (R13).

> NOTE: all of the pointers saved on the heap are in tagged form. In the d8 debug log, we will be able to see the pointers in their tagged form. Contrary to that, the SMI in heap is displayed in its untagged form.

# Debug with GDB (and GEF)

```shell
./v8-12.2/d8 --allow-natives-syntax
V8 version 12.2.0 (candidate)
d8> var obj = {x:1, y:2};
undefined
d8> %DebugPrint(obj)
DebugPrint: 0x2d79001ca0e9: [JS_OBJECT_TYPE]
 - map: 0x2d79000da901 <Map[20](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x2d79000c4b21 <Object map = 0x2d79000c415d>
 - elements: 0x2d79000006cd <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x2d79000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2d7900002bb9: [String] in ReadOnlySpace: #x: 1 (const data field 0), location: in-object
    0x2d7900002bc9: [String] in ReadOnlySpace: #y: 2 (const data field 1), location: in-object
 }
0x2d79000da901: [Map] in OldSpace
 - map: 0x2d79000c3c39 <MetaMap (0x2d79000c3c89 <NativeContext[285]>)>
 - type: JS_OBJECT_TYPE
 - instance size: 20
 - inobject properties: 2
 - unused property fields: 0
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x2d79000da8b9 <Map[20](HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x2d7900000a31 <Cell value= 1>
 - instance descriptors (own) #2: 0x2d79001ca119 <DescriptorArray[2]>
 - prototype: 0x2d79000c4b21 <Object map = 0x2d79000c415d>
 - constructor: 0x2d79000c4665 <JSFunction Object (sfi = 0x2d79003354b9)>
 - dependent code: 0x2d79000006dd <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0

{x: 1, y: 2}
d8>
```

Attach GDB to V8 and dump the memory:

```shell
gef➤  x /32x (0x2d79001ca0e9 - 0x1)
0x2d79001ca0e8:	0x000da901	0x000006cd	0x000006cd	0x00000002
0x2d79001ca0f8:	0x00000004	0x0000062d	0x00010001	0x00000000
0x2d79001ca108:	0x000006f5	0x00002bb9	0x00000084	0x00000002
0x2d79001ca118:	0x0000062d	0x00020002	0x00000000	0x000db6a1
0x2d79001ca128:	0x00002bb9	0x00000084	0x00000002	0x00002bc9
0x2d79001ca138:	0x00100484	0x00000002	0x00000105	0x00bab932
0x2d79001ca148:	0x00000adc	0x7566280a	0x6974636e	0x29286e6f
0x2d79001ca158:	0x220a7b20	0x20657375	0x69727473	0x3b227463
```

As we can see, the memory layout is like what we have discussed:

```shell
0x000da901	    0x000006cd	    0x000006cd	    0x00000002
^ map           ^ elements      ^ properties    ^ property x
0x00000004  	...
^ property y    
```