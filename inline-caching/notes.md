- The idea behind inline caching is very simple: we want to create a bypass or fast path that would allow us to quickly, without entering runtime system, load object's property if our assumptions about object and it's properties are correct.
- The idea behind hidden classes boils down to two simple things:
  - runtime system associates a hidden class with each an every object, just like Java VM would associate an instance of java.lang.Class with every object;
  - if layout of the object changes then runtime system will create or find a new hidden class that matches this new layout and attach it to the object;
- Every hidden class is essentially a collection of property descriptors, where each descriptor is either a real property or a transition that points from a class that does not have some property to a class that has this property.
- In V8 hidden classes actually form a forest - there are multiple root classes, e.g. one for each constructor. This is partially due to the fact that hidden classes in V8 encapsulate constructor specific information, e.g. prototype poiinter is actually stored in the hidden class and not in the object itself so classes with different prototypes must have different hidden classes even if they have the same structure.
- One of many ways to implement an inline cache is to split it into two pieces: modifiable call site in the generated code and a set of stubs (small pieces of generated native code) that can be called from that call site. It is essential that stubs themselves (or runtime system) could find callsite from which they were called: stubs contain only fast paths compiled under certain assumptions, if those assumptions do not apply for an object that stub sees then it can initiate modification (patching) of the call site that invoked this stub to adapt that site for new circumstances.