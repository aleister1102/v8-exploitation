# Folded Allocation

When creating an array in V8, the space to be used by the elements is first allocated and then the array structure is created, so a total of two allocations are performed.

Take this script as an example:

```js
function f() {
    let a = [1.1];
    % DebugPrint(a);
}

% PrepareFunctionForOptimization(f);
f();
% OptimizeMaglevOnNextCall(f);
f();
```

Output:

```shell
../v8-prebuilt/v8-12.2-vuln/d8 --allow-natives-syntax --trace-maglev-graph-building root-cause/1-folded_allocation.js --shell
Concurrent maglev has been disabled for tracing.
DebugPrint: 0x3cb9001ca1dd: [JSArray]
 - map: 0x3cb9000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x3cb9000ce935 <JSArray[0]>
 - elements: 0x3cb9001ca1f5 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x3cb9000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x3cb900000d41: [String] in ReadOnlySpace: #length: 0x3cb90030f82d <AccessorInfo name= 0x3cb900000d41 <String[6]: #length>, data= 0x3cb900000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x3cb9001ca1f5 <FixedDoubleArray[1]> {
           0: 1.1
}
```

Memory dump at `JSArray` object:

```shell
gef➤  x/10x 0x3cb9001ca1dd - 1
0x3cb9001ca1dc:	0x000cefc1	0x000006cd	0x001ca1f5	0x00000002
                                          ^^^^^^^^^^
                                          elements
0x3cb9001ca1ec:	0x00001085	0x000daa39	0x00000851	0x00000002
                                          ^
                                          elements located here and not continuous from JSArray
0x3cb9001ca1fc:	0x9999999a	0x3ff19999
```

Where `0x001ca1e9` is pointer to `FixedDoubleArray` object.

```shell
gef➤  x/10x 0x3cb9001ca1f5 - 1
0x3cb9001ca1f4:	0x00000851	0x00000002	0x9999999a	0x3ff19999
                                          ^^^^^^^^^^^^^^^^^^^^^^
                                                   1.1
0x3cb9001ca204:	0x000005dd	0x00000008	0x00000004	0x000dab17
0x3cb9001ca214:	0x00000100	0x00000061
```

Structure of `JSArray`:

```shell
d8> %DebugPrintPtr(0x3cb9001ca1f5)
DebugPrint: 0x3cb9001ca1f5: [FixedDoubleArray]
 - map: 0x3cb900000851 <Map(FIXED_DOUBLE_ARRAY_TYPE)>
 - length: 1
           0: 1.1
```

The second byte is the `length` and the next following bytes are elements:

```shell
gef➤  print/f 0x3ff199999999999a
$1 = 1.1000000000000001
```

> **The above memory dump is before Maglev folded allocation and the below log is from another instance**

There are 2 allocations:

```shell
0x6353d84fd140  n1: InitialValue(<this>) → (x), 0 uses
  0x6353d84fd5a8  n5: FunctionEntryStackCheck
  0x6353d84fd618  n6: Jump
   0 : 7b 00 00 25       CreateArrayLiteral [0], [0], #37
== New block (merge) at 0x0095000da885 <SharedFunctionInfo f>==
  0x6353d84fddd8  n7: AllocateRaw(Young, 16) → (x), 0 uses <---- allocation for FixedDoubleArray (elements)
  ! Clearing unstable node aspects
  0x6353d84fde48  n8: StoreMap(0x009500000851 <Map(FIXED_DOUBLE_ARRAY_TYPE)>) [n7:(x)]
  0x6353d84fdf30  n10: StoreTaggedFieldNoWriteBarrier(0x4) [n7:(x), n9:(x)]
  ! Clearing unstable node aspects
  0x6353d84fe008  n12: StoreFloat64(0x8) [n7:(x), n11:(x)]
  0x6353d84fe040  n13: FoldedAllocation(+16) [n7:(x)] → (x), 0 uses <---- allocation for JSArray (a)
  ! Clearing unstable node aspects
  0x6353d84fe0b0  n14: StoreMap(0x0095000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)>) [n13:(x)]
  0x6353d84fe1f0  n16: StoreTaggedFieldNoWriteBarrier(0x4) [n13:(x), n15:(x)]
  0x6353d84fe248  n17: StoreTaggedFieldNoWriteBarrier(0xc) [n13:(x), n9:(x)]
  0x6353d84fe2a0  n18: StoreTaggedFieldNoWriteBarrier(0x8) [n13:(x), n7:(x)]
   4 : c6                Star0
   5 : 65 af 01 f9 01    CallRuntime [DebugPrint], r0-r0
  ! Clearing unstable node aspects
  0x6353d84fe380  n19: CallRuntime(DebugPrint) [n3:(x), n13:(x)] → (x), 0 uses
  10 : 0e                LdaUndefined
  11 : ab                Return
  0x6353d84fe428  n20: ReduceInterruptBudgetForReturn(11)
  0x6353d84fe460  n21: Return [n4:(x)]

```

Output:

```shell
DebugPrint: 0x95001ca24d: [JSArray]
 - map: 0x0095000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x0095000ce935 <JSArray[0]>
 - elements: 0x0095001ca23d <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x0095000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x9500000d41: [String] in ReadOnlySpace: #length: 0x00950030f82d <AccessorInfo name= 0x009500000d41 <String[6]: #length>, data= 0x009500000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x0095001ca23d <FixedDoubleArray[1]> {
           0: 1.1
 }
```

The memory dump of `JSArray`:

```shell
gef➤  x/10x 0x95001ca24d - 1
0x95001ca24c:	0x000cefc1	0x000006cd	0x001ca23d	0x00000002
                                      ^^^^^^^^^^
                                        elements
0x95001ca25c:	0x00000105	0x00000003	0x00000004	0x29386428
0x95001ca26c:	0xbeadbeef	0xbeadbeef
```

The memory dump of `FixedDoubleArray`:

```shell
gef➤  x/10x 0x0095001ca23d - 1
0x95001ca23c:	0x00000851	0x00000002	0x9999999a	0x3ff19999 <-- FixedDoubleArray
                                      ^^^^^^^^^^^^^^^^^^^^^^
                                               1.1
0x95001ca24c:	0x000cefc1	0x000006cd	0x001ca23d	0x00000002 <-- JSArray
^^^^^^^^^^^^
JSArray
0x95001ca25c:	0x00000105	0x00000003
```

As we can see, `FixedDoubleArray` is allocated before the `JSArray` 16 bytes.

```shell
gef➤  p 0x0095001ca24d - 0x95001ca23d
$2 = 0x10
```

The machine code:

![alt text](folded-allocation-JSArray.png)

Source code:

```c
/* src/heap/heap-inl.h */

Address* Heap::NewSpaceAllocationTopAddress() {
  return new_space_
             ? isolate()->isolate_data()->new_allocation_info_.top_address()
             : nullptr;
}

Address* Heap::NewSpaceAllocationLimitAddress() {
  return new_space_
             ? isolate()->isolate_data()->new_allocation_info_.limit_address()
             : nullptr;
}
```

Where `Heap::NewSpaceAllocationTopAddress()` is the starting address of the currently allocable free memory, and `Heap::NewSpaceAllocationLimitAddress()` is the ending address. It can be understood that it plays the same role as the top chunk of the Glibc heap.

As we can see, it stores starting address in `rdi` and increments the starting address by `0x20 = 32` bytes and compare with the ending address to check if it beyond the heap address limit. In general, it allocates 32 bytes for `JSArray` and `FixedDoubleArray` (16 bytes per object).

After that is the folded allocation from the `rdi` register (starting address) with offset `0x10 = 16` bytes for `JSArray`:

![alt text](folded-allocation-FixedDoubleArray.png)

The above code equivalent to node `n13` in the Maglev graph.

# Analysis

## Patch

```diff
diff --git a/src/maglev/maglev-graph-builder.cc b/src/maglev/maglev-graph-builder.cc
index ad7eccf..3dd3df5 100644
--- a/src/maglev/maglev-graph-builder.cc
+++ b/src/maglev/maglev-graph-builder.cc
@@ -5597,6 +5597,7 @@
           object = BuildAllocateFastObject(
               FastObject(new_target_function->AsJSFunction(), zone(), broker()),
               AllocationType::kYoung);
+          ClearCurrentRawAllocation();
         } else {
           object = BuildCallBuiltin<Builtin::kFastNewObject>(
               {GetConstant(current_function), new_target});
```

