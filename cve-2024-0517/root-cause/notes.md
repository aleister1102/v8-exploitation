# Folded Allocation

When creating an array in V8, the space to be used by the elements is first allocated and then the array structure is created, so a total of two allocations are performed.

Take this script as an example:

```js
function f() {
    let a = [1.1];
    % DebugPrint(a);
}

% PrepareFunctionForOptimization(f);
f();
% OptimizeMaglevOnNextCall(f);
f();
```

Output:

```js
../v8-prebuilt/v8-12.2-vuln/d8 --allow-natives-syntax --trace-maglev-graph-building  --shell root-cause/1-folded-allocation.js
Concurrent maglev has been disabled for tracing.
DebugPrint: 0x2237001ca1dd: [JSArray]
 - map: 0x2237000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2237000ce935 <JSArray[0]>
 - elements: 0x2237001ca1f5 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x2237000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x223700000d41: [String] in ReadOnlySpace: #length: 0x22370030f82d <AccessorInfo name= 0x223700000d41 <String[6]: #length>, data= 0x223700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x2237001ca1f5 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

Memory dump at `JSArray` object:

```c
gef➤  x/12wx 0x2237001ca1dd - 1
0x2237001ca1dc: 0x000cefc1 0x000006cd 0x001ca1f5 0x00000002
                                      ^^^^^^^^^^
                                       elements
0x2237001ca1ec: 0x00001085 0x000daa39 0x00000851 0x00000002
                                      ^
                                      elements located here
0x2237001ca1fc: 0x9999999a 0x3ff19999 0x000005dd 0x00000008
```

Where `0x001ca1f5` is pointer to a `FixedDoubleArray` object.

```c
gef➤  x/8wx 0x2237001ca1f5 - 1
0x2237001ca1f4: 0x00000851 0x00000002 0x9999999a 0x3ff19999
                                      ^^^^^^^^^^ ^^^^^^^^^^
                                              1.1
0x2237001ca204: 0x000005dd 0x00000008 0x00000004 0x000dab17
```

Structure of `FixedDoubleArray`:

```js
d8> %DebugPrintPtr(0x2237001ca1f5)
DebugPrint: 0x2237001ca1f5: [FixedDoubleArray]
 - map: 0x223700000851 <Map(FIXED_DOUBLE_ARRAY_TYPE)>
 - length: 1
           0: 1.1
```

The second byte is the `length` and the next following bytes are elements:

```c
gef➤  print/f 0x3ff199999999999a
$1 = 1.1000000000000001
```

> **The above memory dump is before Maglev folded allocation and the following is after Maglev folded allocation.**

There are 2 allocations:

```c
  0x61c24beef140  n1: InitialValue(<this>) → (x), 0 uses
  0x61c24beef5a8  n5: FunctionEntryStackCheck
  0x61c24beef618  n6: Jump
   0 : 7b 00 00 25       CreateArrayLiteral [0], [0], #37
== New block (merge) at 0x2237000da885 <SharedFunctionInfo f>==
  0x61c24beefdd8  n7: AllocateRaw(Young, 16) → (x), 0 uses
  ! Clearing unstable node aspects
  0x61c24beefe48  n8: StoreMap(0x223700000851 <Map(FIXED_DOUBLE_ARRAY_TYPE)>) [n7:(x)]
  0x61c24beeff30  n10: StoreTaggedFieldNoWriteBarrier(0x4) [n7:(x), n9:(x)]
  ! Clearing unstable node aspects
  0x61c24bef0008  n12: StoreFloat64(0x8) [n7:(x), n11:(x)]
  0x61c24bef0040  n13: FoldedAllocation(+16) [n7:(x)] → (x), 0 uses
  ! Clearing unstable node aspects
  0x61c24bef00b0  n14: StoreMap(0x2237000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)>) [n13:(x)]
  0x61c24bef01f0  n16: StoreTaggedFieldNoWriteBarrier(0x4) [n13:(x), n15:(x)]
  0x61c24bef0248  n17: StoreTaggedFieldNoWriteBarrier(0xc) [n13:(x), n9:(x)]
  0x61c24bef02a0  n18: StoreTaggedFieldNoWriteBarrier(0x8) [n13:(x), n7:(x)]
   4 : c6                Star0
   5 : 65 af 01 f9 01    CallRuntime [DebugPrint], r0-r0
  ! Clearing unstable node aspects
  0x61c24bef0380  n19: CallRuntime(DebugPrint) [n3:(x), n13:(x)] → (x), 0 uses
  10 : 0e                LdaUndefined
  11 : ab                Return
  0x61c24bef0428  n20: ReduceInterruptBudgetForReturn(11)
  0x61c24bef0460  n21: Return [n4:(x)]
```

Output:

```js
DebugPrint: 0x2237001ca24d: [JSArray]
 - map: 0x2237000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x2237000ce935 <JSArray[0]>
 - elements: 0x2237001ca23d <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x2237000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x223700000d41: [String] in ReadOnlySpace: #length: 0x22370030f82d <AccessorInfo name= 0x223700000d41 <String[6]: #length>, data= 0x223700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x2237001ca23d <FixedDoubleArray[1]> {
           0: 1.1
 }
```

The memory dump of `JSArray`:

```c
gef➤  x/4wx 0x2237001ca24d - 1
0x2237001ca24c: 0x000cefc1 0x000006cd 0x001ca23d 0x00000002
                                      ^^^^^^^^^^
                                       elements
```

The memory dump of `FixedDoubleArray`:

```c
gef➤  x/8wx 0x2237001ca23d - 1
0x2237001ca23c: 0x00000851 0x00000002 0x9999999a 0x3ff19999 <-- FixedDoubleArray
                                      ^^^^^^^^^^ ^^^^^^^^^^
                                              1.1
0x2237001ca24c: 0x000cefc1 0x000006cd 0x001ca23d 0x00000002 <-- JSArray
                                      ^^^^^^^^^^
                                       elements   
```

As we can see, `FixedDoubleArray` is allocated before the `JSArray` 16 bytes.

```c
gef➤  p/u 0x2237001ca24d - 0x2237001ca23d
$2 = 16
```

And 16 bytes is the size of `FixedDoubleArray` object, including the Map pointer, the length of the array and the 1.1 value. This value is also the size of `JSArray` object, including the Map pointer, the prototype pointer, the elements pointer, the length of the array.

The machine code:

![alt text](1-folded-allocation-JSArray.png)

Source code:

```c
/* src/heap/heap-inl.h */

Address* Heap::NewSpaceAllocationTopAddress() {
  return new_space_
             ? isolate()->isolate_data()->new_allocation_info_.top_address()
             : nullptr;
}

Address* Heap::NewSpaceAllocationLimitAddress() {
  return new_space_
             ? isolate()->isolate_data()->new_allocation_info_.limit_address()
             : nullptr;
}
```

Where `Heap::NewSpaceAllocationTopAddress()` is the starting address of the currently allocable free memory, and `Heap::NewSpaceAllocationLimitAddress()` is the ending address. It can be understood that it plays the same role as the top chunk of the Glibc heap.

As we can see, it stores starting address in `rdi` and increments the starting address by `0x20 = 32` bytes and compare with the ending address to check if it beyond the heap address limit. If it is not beyond the limit, it will allocate the memory with `0x20 = 32` bytes.

After that is the folded allocation from the `rdi` register (starting address) with offset `0x10 = 16` bytes for `JSArray`:

![alt text](1-folded-allocation-FixedDoubleArray.png)

The above code equivalent to node `n13` in the Maglev graph.

# Analysis

## Patch

```diff
diff --git a/src/maglev/maglev-graph-builder.cc b/src/maglev/maglev-graph-builder.cc
index ad7eccf..3dd3df5 100644
--- a/src/maglev/maglev-graph-builder.cc
+++ b/src/maglev/maglev-graph-builder.cc
@@ -5597,6 +5597,7 @@
           object = BuildAllocateFastObject(
               FastObject(new_target_function->AsJSFunction(), zone(), broker()),
               AllocationType::kYoung);
+          ClearCurrentRawAllocation();
         } else {
           object = BuildCallBuiltin<Builtin::kFastNewObject>(
               {GetConstant(current_function), new_target});
```

This is what `ClearCurrentRawAllocation()` does:

```c
/* src/maglev/maglev-graph-builder.cc */

void MaglevGraphBuilder::ClearCurrentRawAllocation() {
  current_raw_allocation_ = nullptr;
}
```

## FindNonDefaultConstructorOrConstruct

Examine the following script:

```js
class A { } // default base constructor
class B extends A { } // derived constructor

% PrepareFunctionForOptimization(B);
new B();
% OptimizeMaglevOnNextCall(B);
new B();
```

Derived constructor refers to the constructor of a class that has a parent (inherited). In order for V8 to create an object from a derived constructor, it must also know the structure of the parent class, so it must access the constructor's prototype. However, since the parent class can also have a parent, you have to access the prototype in chain and eventually find the constructor (default base constructor) of the class that does not have a parent.

```js
../v8-prebuilt/v8-12.2-vuln/d8 --allow-natives-syntax --trace-maglev-graph-building root-cause/2-call-bug-function.js --shell 
Concurrent maglev has been disabled for tracing.
Compiling 0x0852001ca27d <JSFunction B (sfi = 0x852000da8e9)> with Maglev
Parameter count 1
Register count 7
Frame size 56
         0x37ea000021f8 @    0 : 19 fe f8          Mov <closure>, r1
         0x37ea000021fb @    3 : 5a f8 f9 f4       FindNonDefaultConstructorOrConstruct r1, r0, r5-r6
         0x37ea000021ff @    7 : 0b f4             Ldar r5
         0x37ea00002201 @    9 : 19 f8 f7          Mov r1, r2
         0x37ea00002204 @   12 : 19 f9 f6          Mov r0, r3
         0x37ea00002207 @   15 : 19 f3 f5          Mov r6, r4
         0x37ea0000220a @   18 : 9a 0a             JumpIfTrue [10] (0x37ea00002214 @ 28)
```

The `FindNonDefaultConstructorOrConstruct` instruction used in the derived constructor (`B()`) searches the constructor's prototype chain to find the default constructor (`A()`) and uses that information to create an object. When the derived constructor is compiled with Maglev, the `FindNonDefaultConstructorOrConstruct` instruction is processed in the `TryBuildFindNonDefaultConstructorOrConstruct()` function.

## TryBuildFindNonDefaultConstructorOrConstruct

```c
/* src/maglev/maglev-graph-builder.cc */

bool MaglevGraphBuilder::TryBuildFindNonDefaultConstructorOrConstruct(
    ValueNode* this_function, ValueNode* new_target,
    std::pair<interpreter::Register, interpreter::Register> result) {
  // See also:
  // JSNativeContextSpecialization::ReduceJSFindNonDefaultConstructorOrConstruct

  compiler::OptionalHeapObjectRef maybe_constant =
      TryGetConstant(this_function);
  if (!maybe_constant) return false;

  compiler::MapRef function_map = maybe_constant->map(broker()); // <-- get map
  compiler::HeapObjectRef current = function_map.prototype(broker()); // <-- get prototype from Map
...
  while (true) {
    if (!current.IsJSFunction()) return false;
    compiler::JSFunctionRef current_function = current.AsJSFunction();
...
    // Keep walking up the class tree.
    current = current_function.map(broker()).prototype(broker()); // <-- loop over prototype chain
  }
}
```

`this_function` passed as an argument is a constructor that calls the `FindNonDefaultConstructorOrConstruct` instruction. `new_target` corresponds to [`new.target`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor#description) which can be accessed inside `constructor()` of the class. The initial value of `current` is the prototype of `this_function`, and then it is processed up the prototype chain in the `while` statement.

> So, `this_function` is `B()`, `new_target` also is `B()` (it is the class called with `new` keyword) and `current` is the prototype of class `B` which is class `A`.

```c
FunctionKind kind = current_function.shared(broker()).kind();
    if (kind != FunctionKind::kDefaultDerivedConstructor) {
      // The hierarchy walk will end here; this is the last change to bail out
      // before creating new nodes.
      if (!broker()->dependencies()->DependOnArrayIteratorProtector()) {
        return false;
      }

      compiler::OptionalHeapObjectRef new_target_function =
          TryGetConstant(new_target);
      if (kind == FunctionKind::kDefaultBaseConstructor) {
        // Store the result register first, so that a lazy deopt in
        // `FastNewObject` writes `true` to this register.
        StoreRegister(result.first, GetBooleanConstant(true));

        ValueNode* object;
        if (new_target_function && new_target_function->IsJSFunction() &&
            HasValidInitialMap(new_target_function->AsJSFunction(),
                               current_function)) {
          object = BuildAllocateFastObject(
              FastObject(new_target_function->AsJSFunction(), zone(), broker()),
              AllocationType::kYoung);
        } else {
          object = BuildCallBuiltin<Builtin::kFastNewObject>(
              {GetConstant(current_function), new_target});
          // We've already stored "true" into result.first, so a deopt here just
          // has to store result.second. Also mark result.first as being used,
          // since the lazy deopt frame won't have marked it since it used to be
          // a result register.
          current_interpreter_frame_.get(result.first)->add_use();
          object->lazy_deopt_info()->UpdateResultLocation(result.second, 1);
        }
        StoreRegister(result.second, object);
      } else {
```

If `current_function` is the default base constructor (`kind == FunctionKind::kDefaultBaseConstructor`), check whether the initial Map of `new_target_function` and `current_function` match to prevent type confusion. (`HasValidInitialMap(new_target_function->AsJSFunction(), current_function)`) and then call `BuildAllocateFastObject()` to compile the code that creates the object.

> `current_function` in this case is `A()` and `new_target_function` is `B()`, same with `this_function`.

## BuildAllocateFastObject

```c
/* src/maglev/maglev-graph-builder.cc */

ValueNode* MaglevGraphBuilder::BuildAllocateFastObject(
    FastObject object, AllocationType allocation_type) {
...
  // TODO(leszeks): Fold allocations.
  ValueNode* allocation = ExtendOrReallocateCurrentRawAllocation(
      object.instance_size, allocation_type);
...
}
```

`BuildAllocateFastObject()` calls `ExtendOrReallocateCurrentRawAllocation()`, and in this function, it determines whether to allocate new space for the object or apply allocation folding depending on the value of `current_raw_allocation_`.

## ExtendOrReallocateCurrentRawAllocation

```c
/* src/maglev/maglev-graph-builder.h */

class MaglevGraphBuilder {
...
  AllocateRaw* current_raw_allocation_ = nullptr;
```

As we can see, `current_raw_allocation_` is a pointer to the `AllocateRaw` object.

```c
/* src/maglev/maglev-ir.h */

class AllocateRaw : public FixedInputValueNodeT<0, AllocateRaw> {
...
  // Allow increasing the size for allocation folding.
  void extend(int size) {
    DCHECK_GT(size, 0);
    size_ += size;
  }

 private:
  AllocationType allocation_type_;
  int size_;
};
```

The `extend()` method just increases the `size_` of the object by the given value.

```c
/* src/maglev/maglev-graph-builder.cc */

ValueNode* MaglevGraphBuilder::ExtendOrReallocateCurrentRawAllocation(
    int size, AllocationType allocation_type) {
  if (!current_raw_allocation_ ||
      current_raw_allocation_->allocation_type() != allocation_type ||
      !v8_flags.inline_new) {
    current_raw_allocation_ =
        AddNewNode<AllocateRaw>({}, allocation_type, size);
    return current_raw_allocation_;
  }

  int current_size = current_raw_allocation_->size();
  if (current_size + size > kMaxRegularHeapObjectSize) {
    return current_raw_allocation_ =
               AddNewNode<AllocateRaw>({}, allocation_type, size);
  }

  DCHECK_GT(current_size, 0);
  int previous_end = current_size;
  current_raw_allocation_->extend(size);
  return AddNewNode<FoldedAllocation>({current_raw_allocation_}, previous_end);
}
```

If `current_raw_allocation_` is not `nullptr` when `ExtendOrReallocateCurrentRawAllocation()` is called, it is determined that the most recent allocation and the allocation currently being processed can be folded. If the maximum size (`kMaxRegularHeapObjectSize`) is exceeded when folded, it is processed as `AllocateRaw`. Otherwise, it is processed as `FoldedAllocation`.

# Bug

```c
        if (new_target_function && new_target_function->IsJSFunction() &&
            HasValidInitialMap(new_target_function->AsJSFunction(),
                               current_function)) {
          object = BuildAllocateFastObject(
              FastObject(new_target_function->AsJSFunction(), zone(), broker()),
              AllocationType::kYoung);
        } else {
```

After calling `TryBuildFindNonDefaultConstructorOrConstruct()` to `BuildAllocateFastObject()`, there is a bug that does not set `current_raw_allocation_` to `nullptr`. If the derived constructor creates another object immediately after calling super() , allocation folding is applied due to `current_raw_allocation_`, which is not set to `nullptr` in `super()`, and if there is another object behind the `super()` object, it will cause problems.

Examine this script:

```js
var x;
let a;
class A { }
class B extends A {
    constructor() {
        x = new.target;
        super();
        a = [1.1];
    }
}

% PrepareFunctionForOptimization(B);
new B();
% OptimizeMaglevOnNextCall(B);
let b = new B();
```

Due to `current_raw_allocation_` is not cleared, any object created after the invocation of `super()` will lie after `b` object.

The bytecode:

```c
  0x629d344231d8  n1: InitialValue(<this>) → (x), 0 uses
  0x629d34423870  n5: RegisterInput(rdx) → (x), 0 uses
  0x629d34423930  n6: FunctionEntryStackCheck
  0x629d344239b8  n7: Jump
   0 : 19 fe f8          Mov <closure>, r1
== New block (merge) at 0x31e7000da905 <SharedFunctionInfo B>==
   3 : 0b f9             Ldar r0
   5 : 23 00 00          StaGlobal [0], [0]
  0x629d34423e10  n8: CheckValue(0x31e7001ca2a9 <JSFunction B (sfi = 0x31e7000da905)>) [n5:(x)]
   8 : 5a fe f9 f4       FindNonDefaultConstructorOrConstruct <closure>, r0, r5-r6
  0x629d34424318  n11: AllocateRaw(Young, 12) → (x), 0 uses <---- allocation for `b`
  ! Clearing unstable node aspects
  0x629d34424388  n12: StoreMap(0x31e7000dad9d <Map[60](HOLEY_ELEMENTS)>) [n11:(x)]
  0x629d344244d0  n13: StoreTaggedFieldNoWriteBarrier(0x4) [n11:(x), n10:(x)]
  0x629d34424528  n14: StoreTaggedFieldNoWriteBarrier(0x8) [n11:(x), n10:(x)]
```

```c
== New block (merge) at 0x31e7000da905 <SharedFunctionInfo B>==
  37 : ae                ThrowSuperAlreadyCalledIfNotHole
  0x629d34424a10  n16: ThrowSuperAlreadyCalledIfNotHole [n1:(x)]
  38 : 19 f6 02          Mov r3, <this>
  41 : 7b 01 04 25       CreateArrayLiteral [1], [4], #37
  0x629d344251b8  n17: FoldedAllocation(+12) [n11:(x)] → (x), 0 uses <----- allocation for `a`, folded with `b`
  ! Clearing unstable node aspects
  0x629d34425228  n18: StoreMap(0x31e700000851 <Map(FIXED_DOUBLE_ARRAY_TYPE)>) [n17:(x)]
```

Indeed, if we look at the memory dump, we can see that the backing store (`elements`) of `a` is allocated after the `b` object exactly 12 bytes. 

```js
d8> %DebugPrint(b)
DebugPrint: 0x31e7001ca55d: [JS_OBJECT_TYPE]
 - map: 0x31e7000dad9d <Map[12](HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x31e7001ca2c9 <B map = 0x31e7000dadc5>
 - elements: 0x31e7000006cd <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x31e7000006cd <FixedArray[0]>
 - All own properties (excluding elements): {}
0x31e7000dad9d: [Map] in OldSpace
 - map: 0x31e7000c3c39 <MetaMap (0x31e7000c3c89 <NativeContext[285]>)>
 - type: JS_OBJECT_TYPE
 - instance size: 12
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x31e700000061 <undefined>
 - prototype_validity cell: 0x31e700000a31 <Cell value= 1>
 - instance descriptors (own) #0: 0x31e700000701 <DescriptorArray[0]>
 - prototype: 0x31e7001ca2c9 <B map = 0x31e7000dadc5>
 - constructor: 0x31e7001ca1f9 <JSFunction A (sfi = 0x31e7000da8c5)>
 - dependent code: 0x31e7001ca501 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0

{}

d8> %DebugPrint(a)
DebugPrint: 0x31e7001ca579: [JSArray]
 - map: 0x31e7000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x31e7000ce935 <JSArray[0]>
 - elements: 0x31e7001ca569 <FixedDoubleArray[1]> [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x31e7000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x31e700000d41: [String] in ReadOnlySpace: #length: 0x31e70030f82d <AccessorInfo name= 0x31e700000d41 <String[6]: #length>, data= 0x31e700000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x31e7001ca569 <FixedDoubleArray[1]> {
           0: 1.1
 }
```

```c
gef➤  p/u 0x31e7001ca569 - 0x31e7001ca55d
$4 = 12
```

Also, there is a folded allocation of 28 bytes for `a` object itself (`JSArray` object) after the `elements` of `a` object:

```c
  0x629d344253e8  n22: StoreFloat64(0x8) [n17:(x), n21:(x)]
  0x629d34425420  n23: FoldedAllocation(+28) [n11:(x)] → (x), 0 uses
  ! Clearing unstable node aspects
  0x629d34425490  n24: StoreMap(0x31e7000cefc1 <Map[16](PACKED_DOUBLE_ELEMENTS)>) [n23:(x)]
  0x629d34425550  n25: StoreTaggedFieldNoWriteBarrier(0x4) [n23:(x), n10:(x)]
  0x629d344255a8  n26: StoreTaggedFieldNoWriteBarrier(0xc) [n23:(x), n19:(x)]
  0x629d34425600  n27: StoreTaggedFieldNoWriteBarrier(0x8) [n23:(x), n17:(x)]
```

If the garbage collection occurs between `super() `and `a = [1.1]`, it causes problems.

Take this script as example:

```js
// Flags: --allow-natives-syntax --expose-gc
function gc() {
  for (let i = 0; i < 1000; i++) {
      new ArrayBuffer(0x10000);
  }
}

var x;
let a;
class A { }
class B extends A {
    constructor() {
        x = new.target;
        super();
        gc();
        // a = [1.1];
    }
}

% PrepareFunctionForOptimization(B);
new B();
% OptimizeMaglevOnNextCall(B);
let b = new B();
% DebugPrint(b);
```

Once the garbage collection is completed, a `FreeSpace` object will be placed directly behind `b`.

```c
/* src/objects/free-space.h */

// FreeSpace are fixed-size free memory blocks used by the heap and GC.
// They look like heap objects (are heap object tagged and have a map) so that
// the heap remains iterable.  They have a size and a next pointer.
// The next pointer is the raw address of the next FreeSpace object (or NULL)
// in the free list.
//
// When external code space is enabled next pointer is stored as Smi values
// representing a diff from current FreeSpace object address in kObjectAlignment
// chunks. Terminating FreeSpace value is represented as Smi zero.
// Such a representation has the following properties:
// a) it can hold both positive an negative diffs for full pointer compression
//    cage size (HeapObject address has only valuable 30 bits while Smis have
//    31 bits),
// b) it's independent of the pointer compression base and pointer compression
//    scheme.
class FreeSpace : public TorqueGeneratedFreeSpace<FreeSpace, HeapObject> {
 public:
  // [size]: size of the free space including the header.
  DECL_RELAXED_INT_ACCESSORS(size)
  static inline void SetSize(const WritableFreeSpace& writable_free_space,
                             int size, RelaxedStoreTag);
  inline int Size();

  // Accessors for the next field.
  inline Tagged<FreeSpace> next() const;
  inline void SetNext(const WritableFreeSpace& writable_free_space,
                      Tagged<FreeSpace> next);

  inline static Tagged<FreeSpace> cast(Tagged<HeapObject> obj);
  inline static Tagged<FreeSpace> unchecked_cast(const Tagged<Object> obj);

  // Dispatched behavior.
  DECL_PRINTER(FreeSpace)

  class BodyDescriptor;

 private:
  inline bool IsValid() const;

  TQ_OBJECT_CONSTRUCTORS(FreeSpace)
};
```

Indeed:

```c

```


The `FreeSpace` object can be understood as feeling similar to freed chunk in `glibc` heap. As many objects are created and deleted during execution, many `FreeSpace` objects are scattered through memory.